import {
  SquareSet
} from "./chunk-3KKNFB47.js";
import {
  COLORS,
  ROLES
} from "./chunk-2LTP2L45.js";

// ../node_modules/chessops/dist/esm/board.js
var Board = class _Board {
  constructor() {
  }
  static default() {
    const board = new _Board();
    board.reset();
    return board;
  }
  /**
   * Resets all pieces to the default starting position for standard chess.
   */
  reset() {
    this.occupied = new SquareSet(65535, 4294901760);
    this.promoted = SquareSet.empty();
    this.white = new SquareSet(65535, 0);
    this.black = new SquareSet(0, 4294901760);
    this.pawn = new SquareSet(65280, 16711680);
    this.knight = new SquareSet(66, 1107296256);
    this.bishop = new SquareSet(36, 603979776);
    this.rook = new SquareSet(129, 2164260864);
    this.queen = new SquareSet(8, 134217728);
    this.king = new SquareSet(16, 268435456);
  }
  static empty() {
    const board = new _Board();
    board.clear();
    return board;
  }
  clear() {
    this.occupied = SquareSet.empty();
    this.promoted = SquareSet.empty();
    for (const color of COLORS)
      this[color] = SquareSet.empty();
    for (const role of ROLES)
      this[role] = SquareSet.empty();
  }
  clone() {
    const board = new _Board();
    board.occupied = this.occupied;
    board.promoted = this.promoted;
    for (const color of COLORS)
      board[color] = this[color];
    for (const role of ROLES)
      board[role] = this[role];
    return board;
  }
  getColor(square) {
    if (this.white.has(square))
      return "white";
    if (this.black.has(square))
      return "black";
    return;
  }
  getRole(square) {
    for (const role of ROLES) {
      if (this[role].has(square))
        return role;
    }
    return;
  }
  get(square) {
    const color = this.getColor(square);
    if (!color)
      return;
    const role = this.getRole(square);
    const promoted = this.promoted.has(square);
    return { color, role, promoted };
  }
  /**
   * Removes and returns the piece from the given `square`, if any.
   */
  take(square) {
    const piece = this.get(square);
    if (piece) {
      this.occupied = this.occupied.without(square);
      this[piece.color] = this[piece.color].without(square);
      this[piece.role] = this[piece.role].without(square);
      if (piece.promoted)
        this.promoted = this.promoted.without(square);
    }
    return piece;
  }
  /**
   * Put `piece` onto `square`, potentially replacing an existing piece.
   * Returns the existing piece, if any.
   */
  set(square, piece) {
    const old = this.take(square);
    this.occupied = this.occupied.with(square);
    this[piece.color] = this[piece.color].with(square);
    this[piece.role] = this[piece.role].with(square);
    if (piece.promoted)
      this.promoted = this.promoted.with(square);
    return old;
  }
  has(square) {
    return this.occupied.has(square);
  }
  *[Symbol.iterator]() {
    for (const square of this.occupied) {
      yield [square, this.get(square)];
    }
  }
  pieces(color, role) {
    return this[color].intersect(this[role]);
  }
  rooksAndQueens() {
    return this.rook.union(this.queen);
  }
  bishopsAndQueens() {
    return this.bishop.union(this.queen);
  }
  /**
   * Finds the unique king of the given `color`, if any.
   */
  kingOf(color) {
    return this.pieces(color, "king").singleSquare();
  }
};
var boardEquals = (left, right) => left.white.equals(right.white) && left.promoted.equals(right.promoted) && ROLES.every((role) => left[role].equals(right[role]));

// ../node_modules/@badrap/result/dist/index.modern.mjs
var r = class {
  unwrap(r2, t2) {
    const e2 = this._chain((t3) => n.ok(r2 ? r2(t3) : t3), (r3) => t2 ? n.ok(t2(r3)) : n.err(r3));
    if (e2.isErr) throw e2.error;
    return e2.value;
  }
  map(r2, t2) {
    return this._chain((t3) => n.ok(r2(t3)), (r3) => n.err(t2 ? t2(r3) : r3));
  }
  chain(r2, t2) {
    return this._chain(r2, t2 || ((r3) => n.err(r3)));
  }
};
var t = class extends r {
  constructor(r2) {
    super(), this.value = void 0, this.isOk = true, this.isErr = false, this.value = r2;
  }
  _chain(r2, t2) {
    return r2(this.value);
  }
};
var e = class extends r {
  constructor(r2) {
    super(), this.error = void 0, this.isOk = false, this.isErr = true, this.error = r2;
  }
  _chain(r2, t2) {
    return t2(this.error);
  }
};
var n;
!function(r2) {
  r2.ok = function(r3) {
    return new t(r3);
  }, r2.err = function(r3) {
    return new e(r3 || new Error());
  }, r2.all = function(t2) {
    if (Array.isArray(t2)) {
      const e3 = [];
      for (let r3 = 0; r3 < t2.length; r3++) {
        const n3 = t2[r3];
        if (n3.isErr) return n3;
        e3.push(n3.value);
      }
      return r2.ok(e3);
    }
    const e2 = {}, n2 = Object.keys(t2);
    for (let r3 = 0; r3 < n2.length; r3++) {
      const s = t2[n2[r3]];
      if (s.isErr) return s;
      e2[n2[r3]] = s.value;
    }
    return r2.ok(e2);
  };
}(n || (n = {}));

export {
  Board,
  boardEquals,
  n
};
//# sourceMappingURL=chunk-FU7V6HOK.js.map
