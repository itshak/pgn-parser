import {
  pgn_exports,
  variant_exports
} from "./chunk-VJGXNM7X.js";
import {
  Material,
  MaterialSide,
  RemainingChecks,
  defaultSetup,
  fen_exports,
  makePiece
} from "./chunk-RMWRCOXF.js";
import {
  san_exports
} from "./chunk-KZ3PHYFN.js";
import {
  Castles,
  Chess,
  IllegalSetup,
  Position,
  PositionError
} from "./chunk-DUUQQ2VO.js";
import {
  Board
} from "./chunk-FU7V6HOK.js";
import {
  attacks,
  between,
  bishopAttacks,
  kingAttacks,
  knightAttacks,
  pawnAttacks,
  queenAttacks,
  ray,
  rookAttacks
} from "./chunk-LPFJRHPV.js";
import {
  SquareSet
} from "./chunk-3KKNFB47.js";
import {
  compat_exports
} from "./chunk-MFUKB4GU.js";
import {
  CASTLING_SIDES,
  COLORS,
  FILE_NAMES,
  RANK_NAMES,
  ROLES,
  RULES,
  charToRole,
  defined,
  isDrop,
  isNormal,
  kingCastlesTo,
  makeSquare,
  makeUci,
  opposite,
  parseSquare,
  parseUci,
  roleToChar,
  squareFile,
  squareRank
} from "./chunk-2LTP2L45.js";
import {
  __export
} from "./chunk-DC5AMYBS.js";

// ../node_modules/chessops/dist/esm/debug.js
var debug_exports = {};
__export(debug_exports, {
  board: () => board,
  dests: () => dests,
  perft: () => perft,
  piece: () => piece,
  square: () => square,
  squareSet: () => squareSet
});
var squareSet = (squares) => {
  const r = [];
  for (let y = 7; y >= 0; y--) {
    for (let x = 0; x < 8; x++) {
      const square2 = x + y * 8;
      r.push(squares.has(square2) ? "1" : ".");
      r.push(x < 7 ? " " : "\n");
    }
  }
  return r.join("");
};
var piece = (piece2) => makePiece(piece2);
var board = (board2) => {
  const r = [];
  for (let y = 7; y >= 0; y--) {
    for (let x = 0; x < 8; x++) {
      const square2 = x + y * 8;
      const p = board2.get(square2);
      const col = p ? piece(p) : ".";
      r.push(col);
      r.push(x < 7 ? col.length < 2 ? " " : "" : "\n");
    }
  }
  return r.join("");
};
var square = (sq) => makeSquare(sq);
var dests = (dests2) => {
  const lines = [];
  for (const [from, to] of dests2) {
    lines.push(`${makeSquare(from)}: ${Array.from(to, square).join(" ")}`);
  }
  return lines.join("\n");
};
var perft = (pos, depth, log = false) => {
  if (depth < 1)
    return 1;
  const promotionRoles = ["queen", "knight", "rook", "bishop"];
  if (pos.rules === "antichess")
    promotionRoles.push("king");
  const ctx = pos.ctx();
  const dropDests = pos.dropDests(ctx);
  if (!log && depth === 1 && dropDests.isEmpty()) {
    let nodes = 0;
    for (const [from, to] of pos.allDests(ctx)) {
      nodes += to.size();
      if (pos.board.pawn.has(from)) {
        const backrank = SquareSet.backrank(opposite(pos.turn));
        nodes += to.intersect(backrank).size() * (promotionRoles.length - 1);
      }
    }
    return nodes;
  } else {
    let nodes = 0;
    for (const [from, dests2] of pos.allDests(ctx)) {
      const promotions = squareRank(from) === (pos.turn === "white" ? 6 : 1) && pos.board.pawn.has(from) ? promotionRoles : [void 0];
      for (const to of dests2) {
        for (const promotion of promotions) {
          const child = pos.clone();
          const move = { from, to, promotion };
          child.play(move);
          const children = perft(child, depth - 1, false);
          if (log)
            console.log(makeUci(move), children);
          nodes += children;
        }
      }
    }
    if (pos.pockets) {
      for (const role of ROLES) {
        if (pos.pockets[pos.turn][role] > 0) {
          for (const to of role === "pawn" ? dropDests.diff(SquareSet.backranks()) : dropDests) {
            const child = pos.clone();
            const move = { role, to };
            child.play(move);
            const children = perft(child, depth - 1, false);
            if (log)
              console.log(makeUci(move), children);
            nodes += children;
          }
        }
      }
    }
    return nodes;
  }
};

// ../node_modules/chessops/dist/esm/transform.js
var transform_exports = {};
__export(transform_exports, {
  flipDiagonal: () => flipDiagonal,
  flipHorizontal: () => flipHorizontal,
  flipVertical: () => flipVertical,
  rotate180: () => rotate180,
  transformBoard: () => transformBoard,
  transformSetup: () => transformSetup
});
var flipVertical = (s) => s.bswap64();
var flipHorizontal = (s) => {
  const k1 = new SquareSet(1431655765, 1431655765);
  const k2 = new SquareSet(858993459, 858993459);
  const k4 = new SquareSet(252645135, 252645135);
  s = s.shr64(1).intersect(k1).union(s.intersect(k1).shl64(1));
  s = s.shr64(2).intersect(k2).union(s.intersect(k2).shl64(2));
  s = s.shr64(4).intersect(k4).union(s.intersect(k4).shl64(4));
  return s;
};
var flipDiagonal = (s) => {
  let t = s.xor(s.shl64(28)).intersect(new SquareSet(0, 252645135));
  s = s.xor(t.xor(t.shr64(28)));
  t = s.xor(s.shl64(14)).intersect(new SquareSet(858980352, 858980352));
  s = s.xor(t.xor(t.shr64(14)));
  t = s.xor(s.shl64(7)).intersect(new SquareSet(1426085120, 1426085120));
  s = s.xor(t.xor(t.shr64(7)));
  return s;
};
var rotate180 = (s) => s.rbit64();
var transformBoard = (board2, f) => {
  const b = Board.empty();
  b.occupied = f(board2.occupied);
  b.promoted = f(board2.promoted);
  for (const color of COLORS)
    b[color] = f(board2[color]);
  for (const role of ROLES)
    b[role] = f(board2[role]);
  return b;
};
var transformSetup = (setup, f) => {
  var _a, _b;
  return {
    board: transformBoard(setup.board, f),
    pockets: (_a = setup.pockets) === null || _a === void 0 ? void 0 : _a.clone(),
    turn: setup.turn,
    castlingRights: f(setup.castlingRights),
    epSquare: defined(setup.epSquare) ? f(SquareSet.fromSquare(setup.epSquare)).first() : void 0,
    remainingChecks: (_b = setup.remainingChecks) === null || _b === void 0 ? void 0 : _b.clone(),
    halfmoves: setup.halfmoves,
    fullmoves: setup.fullmoves
  };
};
export {
  Board,
  CASTLING_SIDES,
  COLORS,
  Castles,
  Chess,
  FILE_NAMES,
  IllegalSetup,
  Material,
  MaterialSide,
  Position,
  PositionError,
  RANK_NAMES,
  ROLES,
  RULES,
  RemainingChecks,
  SquareSet,
  attacks,
  between,
  bishopAttacks,
  charToRole,
  compat_exports as compat,
  debug_exports as debug,
  defaultSetup,
  defined,
  fen_exports as fen,
  isDrop,
  isNormal,
  kingAttacks,
  kingCastlesTo,
  knightAttacks,
  makeSquare,
  makeUci,
  opposite,
  parseSquare,
  parseUci,
  pawnAttacks,
  pgn_exports as pgn,
  queenAttacks,
  ray,
  roleToChar,
  rookAttacks,
  san_exports as san,
  squareFile,
  squareRank,
  transform_exports as transform,
  variant_exports as variant
};
//# sourceMappingURL=chessops.js.map
