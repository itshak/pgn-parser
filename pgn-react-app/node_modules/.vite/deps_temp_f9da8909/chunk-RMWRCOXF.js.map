{
  "version": 3,
  "sources": ["../../../../node_modules/chessops/src/fen.ts", "../../../../node_modules/chessops/src/setup.ts"],
  "sourcesContent": ["import { Result } from '@badrap/result';\nimport { Board } from './board.js';\nimport { Material, MaterialSide, RemainingChecks, Setup } from './setup.js';\nimport { SquareSet } from './squareSet.js';\nimport { Color, COLORS, FILE_NAMES, Piece, ROLES, Square } from './types.js';\nimport { charToRole, defined, makeSquare, parseSquare, roleToChar, squareFile, squareFromCoords } from './util.js';\n\nexport const INITIAL_BOARD_FEN = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR';\nexport const INITIAL_EPD = INITIAL_BOARD_FEN + ' w KQkq -';\nexport const INITIAL_FEN = INITIAL_EPD + ' 0 1';\nexport const EMPTY_BOARD_FEN = '8/8/8/8/8/8/8/8';\nexport const EMPTY_EPD = EMPTY_BOARD_FEN + ' w - -';\nexport const EMPTY_FEN = EMPTY_EPD + ' 0 1';\n\nexport enum InvalidFen {\n  Fen = 'ERR_FEN',\n  Board = 'ERR_BOARD',\n  Pockets = 'ERR_POCKETS',\n  Turn = 'ERR_TURN',\n  Castling = 'ERR_CASTLING',\n  EpSquare = 'ERR_EP_SQUARE',\n  RemainingChecks = 'ERR_REMAINING_CHECKS',\n  Halfmoves = 'ERR_HALFMOVES',\n  Fullmoves = 'ERR_FULLMOVES',\n}\n\nexport class FenError extends Error {}\n\nconst nthIndexOf = (haystack: string, needle: string, n: number): number => {\n  let index = haystack.indexOf(needle);\n  while (n-- > 0) {\n    if (index === -1) break;\n    index = haystack.indexOf(needle, index + needle.length);\n  }\n  return index;\n};\n\nconst parseSmallUint = (str: string): number | undefined => (/^\\d{1,4}$/.test(str) ? parseInt(str, 10) : undefined);\n\nconst charToPiece = (ch: string): Piece | undefined => {\n  const role = charToRole(ch);\n  return role && { role, color: ch.toLowerCase() === ch ? 'black' : 'white' };\n};\n\nexport const parseBoardFen = (boardPart: string): Result<Board, FenError> => {\n  const board = Board.empty();\n  let rank = 7;\n  let file = 0;\n  for (let i = 0; i < boardPart.length; i++) {\n    const c = boardPart[i];\n    if (c === '/' && file === 8) {\n      file = 0;\n      rank--;\n    } else {\n      const step = parseInt(c, 10);\n      if (step > 0) file += step;\n      else {\n        if (file >= 8 || rank < 0) return Result.err(new FenError(InvalidFen.Board));\n        const square = file + rank * 8;\n        const piece = charToPiece(c);\n        if (!piece) return Result.err(new FenError(InvalidFen.Board));\n        if (boardPart[i + 1] === '~') {\n          piece.promoted = true;\n          i++;\n        }\n        board.set(square, piece);\n        file++;\n      }\n    }\n  }\n  if (rank !== 0 || file !== 8) return Result.err(new FenError(InvalidFen.Board));\n  return Result.ok(board);\n};\n\nexport const parsePockets = (pocketPart: string): Result<Material, FenError> => {\n  if (pocketPart.length > 64) return Result.err(new FenError(InvalidFen.Pockets));\n  const pockets = Material.empty();\n  for (const c of pocketPart) {\n    const piece = charToPiece(c);\n    if (!piece) return Result.err(new FenError(InvalidFen.Pockets));\n    pockets[piece.color][piece.role]++;\n  }\n  return Result.ok(pockets);\n};\n\nexport const parseCastlingFen = (board: Board, castlingPart: string): Result<SquareSet, FenError> => {\n  let castlingRights = SquareSet.empty();\n  if (castlingPart === '-') return Result.ok(castlingRights);\n\n  for (const c of castlingPart) {\n    const lower = c.toLowerCase();\n    const color = c === lower ? 'black' : 'white';\n    const rank = color === 'white' ? 0 : 7;\n    if ('a' <= lower && lower <= 'h') {\n      castlingRights = castlingRights.with(squareFromCoords(lower.charCodeAt(0) - 'a'.charCodeAt(0), rank)!);\n    } else if (lower === 'k' || lower === 'q') {\n      const rooksAndKings = board[color].intersect(SquareSet.backrank(color)).intersect(board.rook.union(board.king));\n      const candidate = lower === 'k' ? rooksAndKings.last() : rooksAndKings.first();\n      castlingRights = castlingRights.with(\n        defined(candidate) && board.rook.has(candidate) ? candidate : squareFromCoords(lower === 'k' ? 7 : 0, rank)!,\n      );\n    } else return Result.err(new FenError(InvalidFen.Castling));\n  }\n\n  if (COLORS.some(color => SquareSet.backrank(color).intersect(castlingRights).size() > 2)) {\n    return Result.err(new FenError(InvalidFen.Castling));\n  }\n\n  return Result.ok(castlingRights);\n};\n\nexport const parseRemainingChecks = (part: string): Result<RemainingChecks, FenError> => {\n  const parts = part.split('+');\n  if (parts.length === 3 && parts[0] === '') {\n    const white = parseSmallUint(parts[1]);\n    const black = parseSmallUint(parts[2]);\n    if (!defined(white) || white > 3 || !defined(black) || black > 3) {\n      return Result.err(new FenError(InvalidFen.RemainingChecks));\n    }\n    return Result.ok(new RemainingChecks(3 - white, 3 - black));\n  } else if (parts.length === 2) {\n    const white = parseSmallUint(parts[0]);\n    const black = parseSmallUint(parts[1]);\n    if (!defined(white) || white > 3 || !defined(black) || black > 3) {\n      return Result.err(new FenError(InvalidFen.RemainingChecks));\n    }\n    return Result.ok(new RemainingChecks(white, black));\n  } else return Result.err(new FenError(InvalidFen.RemainingChecks));\n};\n\nexport const parseFen = (fen: string): Result<Setup, FenError> => {\n  const parts = fen.split(/[\\s_]+/);\n  const boardPart = parts.shift()!;\n\n  // Board and pockets\n  let board: Result<Board, FenError>;\n  let pockets = Result.ok<Material | undefined, FenError>(undefined);\n  if (boardPart.endsWith(']')) {\n    const pocketStart = boardPart.indexOf('[');\n    if (pocketStart === -1) return Result.err(new FenError(InvalidFen.Fen));\n    board = parseBoardFen(boardPart.slice(0, pocketStart));\n    pockets = parsePockets(boardPart.slice(pocketStart + 1, -1));\n  } else {\n    const pocketStart = nthIndexOf(boardPart, '/', 7);\n    if (pocketStart === -1) board = parseBoardFen(boardPart);\n    else {\n      board = parseBoardFen(boardPart.slice(0, pocketStart));\n      pockets = parsePockets(boardPart.slice(pocketStart + 1));\n    }\n  }\n\n  // Turn\n  let turn: Color;\n  const turnPart = parts.shift();\n  if (!defined(turnPart) || turnPart === 'w') turn = 'white';\n  else if (turnPart === 'b') turn = 'black';\n  else return Result.err(new FenError(InvalidFen.Turn));\n\n  return board.chain(board => {\n    // Castling\n    const castlingPart = parts.shift();\n    const castlingRights = defined(castlingPart) ? parseCastlingFen(board, castlingPart) : Result.ok(SquareSet.empty());\n\n    // En passant square\n    const epPart = parts.shift();\n    let epSquare: Square | undefined;\n    if (defined(epPart) && epPart !== '-') {\n      epSquare = parseSquare(epPart);\n      if (!defined(epSquare)) return Result.err(new FenError(InvalidFen.EpSquare));\n    }\n\n    // Halfmoves or remaining checks\n    let halfmovePart = parts.shift();\n    let earlyRemainingChecks: Result<RemainingChecks, FenError> | undefined;\n    if (defined(halfmovePart) && halfmovePart.includes('+')) {\n      earlyRemainingChecks = parseRemainingChecks(halfmovePart);\n      halfmovePart = parts.shift();\n    }\n    const halfmoves = defined(halfmovePart) ? parseSmallUint(halfmovePart) : 0;\n    if (!defined(halfmoves)) return Result.err(new FenError(InvalidFen.Halfmoves));\n\n    const fullmovesPart = parts.shift();\n    const fullmoves = defined(fullmovesPart) ? parseSmallUint(fullmovesPart) : 1;\n    if (!defined(fullmoves)) return Result.err(new FenError(InvalidFen.Fullmoves));\n\n    const remainingChecksPart = parts.shift();\n    let remainingChecks: Result<RemainingChecks | undefined, FenError> = Result.ok(undefined);\n    if (defined(remainingChecksPart)) {\n      if (defined(earlyRemainingChecks)) return Result.err(new FenError(InvalidFen.RemainingChecks));\n      remainingChecks = parseRemainingChecks(remainingChecksPart);\n    } else if (defined(earlyRemainingChecks)) {\n      remainingChecks = earlyRemainingChecks;\n    }\n\n    if (parts.length > 0) return Result.err(new FenError(InvalidFen.Fen));\n\n    return pockets.chain(pockets =>\n      castlingRights.chain(castlingRights =>\n        remainingChecks.map(remainingChecks => {\n          return {\n            board,\n            pockets,\n            turn,\n            castlingRights,\n            remainingChecks,\n            epSquare,\n            halfmoves,\n            fullmoves: Math.max(1, fullmoves),\n          };\n        })\n      )\n    );\n  });\n};\n\nexport interface FenOpts {\n  epd?: boolean;\n}\n\nexport const parsePiece = (str: string): Piece | undefined => {\n  if (!str) return;\n  const piece = charToPiece(str[0]);\n  if (!piece) return;\n  if (str.length === 2 && str[1] === '~') piece.promoted = true;\n  else if (str.length > 1) return;\n  return piece;\n};\n\nexport const makePiece = (piece: Piece): string => {\n  let r = roleToChar(piece.role);\n  if (piece.color === 'white') r = r.toUpperCase();\n  if (piece.promoted) r += '~';\n  return r;\n};\n\nexport const makeBoardFen = (board: Board): string => {\n  let fen = '';\n  let empty = 0;\n  for (let rank = 7; rank >= 0; rank--) {\n    for (let file = 0; file < 8; file++) {\n      const square = file + rank * 8;\n      const piece = board.get(square);\n      if (!piece) empty++;\n      else {\n        if (empty > 0) {\n          fen += empty;\n          empty = 0;\n        }\n        fen += makePiece(piece);\n      }\n\n      if (file === 7) {\n        if (empty > 0) {\n          fen += empty;\n          empty = 0;\n        }\n        if (rank !== 0) fen += '/';\n      }\n    }\n  }\n  return fen;\n};\n\nexport const makePocket = (material: MaterialSide): string =>\n  ROLES.map(role => roleToChar(role).repeat(material[role])).join('');\n\nexport const makePockets = (pocket: Material): string =>\n  makePocket(pocket.white).toUpperCase() + makePocket(pocket.black);\n\nexport const makeCastlingFen = (board: Board, castlingRights: SquareSet): string => {\n  let fen = '';\n  for (const color of COLORS) {\n    const backrank = SquareSet.backrank(color);\n    let king = board.kingOf(color);\n    if (defined(king) && !backrank.has(king)) king = undefined;\n    const candidates = board.pieces(color, 'rook').intersect(backrank);\n    for (const rook of castlingRights.intersect(backrank).reversed()) {\n      if (rook === candidates.first() && defined(king) && rook < king) {\n        fen += color === 'white' ? 'Q' : 'q';\n      } else if (rook === candidates.last() && defined(king) && king < rook) {\n        fen += color === 'white' ? 'K' : 'k';\n      } else {\n        const file = FILE_NAMES[squareFile(rook)];\n        fen += color === 'white' ? file.toUpperCase() : file;\n      }\n    }\n  }\n  return fen || '-';\n};\n\nexport const makeRemainingChecks = (checks: RemainingChecks): string => `${checks.white}+${checks.black}`;\n\nexport const makeFen = (setup: Setup, opts?: FenOpts): string =>\n  [\n    makeBoardFen(setup.board) + (setup.pockets ? `[${makePockets(setup.pockets)}]` : ''),\n    setup.turn[0],\n    makeCastlingFen(setup.board, setup.castlingRights),\n    defined(setup.epSquare) ? makeSquare(setup.epSquare) : '-',\n    ...(setup.remainingChecks ? [makeRemainingChecks(setup.remainingChecks)] : []),\n    ...(opts?.epd ? [] : [Math.max(0, Math.min(setup.halfmoves, 9999)), Math.max(1, Math.min(setup.fullmoves, 9999))]),\n  ].join(' ');\n", "import { Board, boardEquals } from './board.js';\nimport { SquareSet } from './squareSet.js';\nimport { ByColor, ByRole, Color, Role, ROLES, Square } from './types.js';\n\nexport class MaterialSide implements ByRole<number> {\n  pawn: number;\n  knight: number;\n  bishop: number;\n  rook: number;\n  queen: number;\n  king: number;\n\n  private constructor() {}\n\n  static empty(): MaterialSide {\n    const m = new MaterialSide();\n    for (const role of ROLES) m[role] = 0;\n    return m;\n  }\n\n  static fromBoard(board: Board, color: Color): MaterialSide {\n    const m = new MaterialSide();\n    for (const role of ROLES) m[role] = board.pieces(color, role).size();\n    return m;\n  }\n\n  clone(): MaterialSide {\n    const m = new MaterialSide();\n    for (const role of ROLES) m[role] = this[role];\n    return m;\n  }\n\n  equals(other: MaterialSide): boolean {\n    return ROLES.every(role => this[role] === other[role]);\n  }\n\n  add(other: MaterialSide): MaterialSide {\n    const m = new MaterialSide();\n    for (const role of ROLES) m[role] = this[role] + other[role];\n    return m;\n  }\n\n  subtract(other: MaterialSide): MaterialSide {\n    const m = new MaterialSide();\n    for (const role of ROLES) m[role] = this[role] - other[role];\n    return m;\n  }\n\n  nonEmpty(): boolean {\n    return ROLES.some(role => this[role] > 0);\n  }\n\n  isEmpty(): boolean {\n    return !this.nonEmpty();\n  }\n\n  hasPawns(): boolean {\n    return this.pawn > 0;\n  }\n\n  hasNonPawns(): boolean {\n    return this.knight > 0 || this.bishop > 0 || this.rook > 0 || this.queen > 0 || this.king > 0;\n  }\n\n  size(): number {\n    return this.pawn + this.knight + this.bishop + this.rook + this.queen + this.king;\n  }\n}\n\nexport class Material implements ByColor<MaterialSide> {\n  constructor(\n    public white: MaterialSide,\n    public black: MaterialSide,\n  ) {}\n\n  static empty(): Material {\n    return new Material(MaterialSide.empty(), MaterialSide.empty());\n  }\n\n  static fromBoard(board: Board): Material {\n    return new Material(MaterialSide.fromBoard(board, 'white'), MaterialSide.fromBoard(board, 'black'));\n  }\n\n  clone(): Material {\n    return new Material(this.white.clone(), this.black.clone());\n  }\n\n  equals(other: Material): boolean {\n    return this.white.equals(other.white) && this.black.equals(other.black);\n  }\n\n  add(other: Material): Material {\n    return new Material(this.white.add(other.white), this.black.add(other.black));\n  }\n\n  subtract(other: Material): Material {\n    return new Material(this.white.subtract(other.white), this.black.subtract(other.black));\n  }\n\n  count(role: Role): number {\n    return this.white[role] + this.black[role];\n  }\n\n  size(): number {\n    return this.white.size() + this.black.size();\n  }\n\n  isEmpty(): boolean {\n    return this.white.isEmpty() && this.black.isEmpty();\n  }\n\n  nonEmpty(): boolean {\n    return !this.isEmpty();\n  }\n\n  hasPawns(): boolean {\n    return this.white.hasPawns() || this.black.hasPawns();\n  }\n\n  hasNonPawns(): boolean {\n    return this.white.hasNonPawns() || this.black.hasNonPawns();\n  }\n}\n\nexport class RemainingChecks implements ByColor<number> {\n  constructor(\n    public white: number,\n    public black: number,\n  ) {}\n\n  static default(): RemainingChecks {\n    return new RemainingChecks(3, 3);\n  }\n\n  clone(): RemainingChecks {\n    return new RemainingChecks(this.white, this.black);\n  }\n\n  equals(other: RemainingChecks): boolean {\n    return this.white === other.white && this.black === other.black;\n  }\n}\n\n/**\n * A not necessarily legal chess or chess variant position.\n */\nexport interface Setup {\n  board: Board;\n  pockets: Material | undefined;\n  turn: Color;\n  castlingRights: SquareSet;\n  epSquare: Square | undefined;\n  remainingChecks: RemainingChecks | undefined;\n  halfmoves: number;\n  fullmoves: number;\n}\n\nexport const defaultSetup = (): Setup => ({\n  board: Board.default(),\n  pockets: undefined,\n  turn: 'white',\n  castlingRights: SquareSet.corners(),\n  epSquare: undefined,\n  remainingChecks: undefined,\n  halfmoves: 0,\n  fullmoves: 1,\n});\n\nexport const setupClone = (setup: Setup): Setup => ({\n  board: setup.board.clone(),\n  pockets: setup.pockets?.clone(),\n  turn: setup.turn,\n  castlingRights: setup.castlingRights,\n  epSquare: setup.epSquare,\n  remainingChecks: setup.remainingChecks?.clone(),\n  halfmoves: setup.halfmoves,\n  fullmoves: setup.fullmoves,\n});\n\nexport const setupEquals = (left: Setup, right: Setup): boolean =>\n  boardEquals(left.board, right.board)\n  && ((right.pockets && left.pockets?.equals(right.pockets)) || (!left.pockets && !right.pockets))\n  && left.turn === right.turn\n  && left.castlingRights.equals(right.castlingRights)\n  && left.epSquare === right.epSquare\n  && ((right.remainingChecks && left.remainingChecks?.equals(right.remainingChecks))\n    || (!left.remainingChecks && !right.remainingChecks))\n  && left.halfmoves === right.halfmoves\n  && left.fullmoves === right.fullmoves;\n"],
  "mappings": "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",
  "names": ["InvalidFen", "n", "board", "pockets", "castlingRights", "remainingChecks"]
}
