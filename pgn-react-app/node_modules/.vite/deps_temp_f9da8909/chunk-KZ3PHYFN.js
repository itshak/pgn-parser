import {
  attacks,
  bishopAttacks,
  kingAttacks,
  knightAttacks,
  queenAttacks,
  rookAttacks
} from "./chunk-LPFJRHPV.js";
import {
  SquareSet
} from "./chunk-3KKNFB47.js";
import {
  FILE_NAMES,
  RANK_NAMES,
  charToRole,
  defined,
  isDrop,
  makeSquare,
  opposite,
  parseSquare,
  roleToChar,
  squareFile,
  squareRank
} from "./chunk-2LTP2L45.js";
import {
  __export
} from "./chunk-DC5AMYBS.js";

// ../node_modules/chessops/dist/esm/san.js
var san_exports = {};
__export(san_exports, {
  makeSan: () => makeSan,
  makeSanAndPlay: () => makeSanAndPlay,
  makeSanVariation: () => makeSanVariation,
  parseSan: () => parseSan
});
var makeSanWithoutSuffix = (pos, move) => {
  let san = "";
  if (isDrop(move)) {
    if (move.role !== "pawn")
      san = roleToChar(move.role).toUpperCase();
    san += "@" + makeSquare(move.to);
  } else {
    const role = pos.board.getRole(move.from);
    if (!role)
      return "--";
    if (role === "king" && (pos.board[pos.turn].has(move.to) || Math.abs(move.to - move.from) === 2)) {
      san = move.to > move.from ? "O-O" : "O-O-O";
    } else {
      const capture = pos.board.occupied.has(move.to) || role === "pawn" && squareFile(move.from) !== squareFile(move.to);
      if (role !== "pawn") {
        san = roleToChar(role).toUpperCase();
        let others;
        if (role === "king")
          others = kingAttacks(move.to).intersect(pos.board.king);
        else if (role === "queen")
          others = queenAttacks(move.to, pos.board.occupied).intersect(pos.board.queen);
        else if (role === "rook")
          others = rookAttacks(move.to, pos.board.occupied).intersect(pos.board.rook);
        else if (role === "bishop")
          others = bishopAttacks(move.to, pos.board.occupied).intersect(pos.board.bishop);
        else
          others = knightAttacks(move.to).intersect(pos.board.knight);
        others = others.intersect(pos.board[pos.turn]).without(move.from);
        if (others.nonEmpty()) {
          const ctx = pos.ctx();
          for (const from of others) {
            if (!pos.dests(from, ctx).has(move.to))
              others = others.without(from);
          }
          if (others.nonEmpty()) {
            let row = false;
            let column = others.intersects(SquareSet.fromRank(squareRank(move.from)));
            if (others.intersects(SquareSet.fromFile(squareFile(move.from))))
              row = true;
            else
              column = true;
            if (column)
              san += FILE_NAMES[squareFile(move.from)];
            if (row)
              san += RANK_NAMES[squareRank(move.from)];
          }
        }
      } else if (capture)
        san = FILE_NAMES[squareFile(move.from)];
      if (capture)
        san += "x";
      san += makeSquare(move.to);
      if (move.promotion)
        san += "=" + roleToChar(move.promotion).toUpperCase();
    }
  }
  return san;
};
var makeSanAndPlay = (pos, move) => {
  var _a;
  const san = makeSanWithoutSuffix(pos, move);
  pos.play(move);
  if ((_a = pos.outcome()) === null || _a === void 0 ? void 0 : _a.winner)
    return san + "#";
  if (pos.isCheck())
    return san + "+";
  return san;
};
var makeSanVariation = (pos, variation) => {
  var _a;
  pos = pos.clone();
  const line = [];
  for (let i = 0; i < variation.length; i++) {
    if (i !== 0)
      line.push(" ");
    if (pos.turn === "white")
      line.push(pos.fullmoves, ". ");
    else if (i === 0)
      line.push(pos.fullmoves, "... ");
    const san = makeSanWithoutSuffix(pos, variation[i]);
    pos.play(variation[i]);
    line.push(san);
    if (san === "--")
      return line.join("");
    if (i === variation.length - 1 && ((_a = pos.outcome()) === null || _a === void 0 ? void 0 : _a.winner))
      line.push("#");
    else if (pos.isCheck())
      line.push("+");
  }
  return line.join("");
};
var makeSan = (pos, move) => makeSanAndPlay(pos.clone(), move);
var parseSan = (pos, san) => {
  const ctx = pos.ctx();
  const match = san.match(/^([NBRQK])?([a-h])?([1-8])?[-x]?([a-h][1-8])(?:=?([nbrqkNBRQK]))?[+#]?$/);
  if (!match) {
    let castlingSide;
    if (san === "O-O" || san === "O-O+" || san === "O-O#")
      castlingSide = "h";
    else if (san === "O-O-O" || san === "O-O-O+" || san === "O-O-O#")
      castlingSide = "a";
    if (castlingSide) {
      const rook = pos.castles.rook[pos.turn][castlingSide];
      if (!defined(ctx.king) || !defined(rook) || !pos.dests(ctx.king, ctx).has(rook))
        return;
      return {
        from: ctx.king,
        to: rook
      };
    }
    const match2 = san.match(/^([pnbrqkPNBRQK])?@([a-h][1-8])[+#]?$/);
    if (!match2)
      return;
    const move = {
      role: match2[1] ? charToRole(match2[1]) : "pawn",
      to: parseSquare(match2[2])
    };
    return pos.isLegal(move, ctx) ? move : void 0;
  }
  const role = match[1] ? charToRole(match[1]) : "pawn";
  const to = parseSquare(match[4]);
  const promotion = match[5] ? charToRole(match[5]) : void 0;
  if (!!promotion !== (role === "pawn" && SquareSet.backranks().has(to)))
    return;
  if (promotion === "king" && pos.rules !== "antichess")
    return;
  let candidates = pos.board.pieces(pos.turn, role);
  if (role === "pawn" && !match[2])
    candidates = candidates.intersect(SquareSet.fromFile(squareFile(to)));
  else if (match[2])
    candidates = candidates.intersect(SquareSet.fromFile(match[2].charCodeAt(0) - "a".charCodeAt(0)));
  if (match[3])
    candidates = candidates.intersect(SquareSet.fromRank(match[3].charCodeAt(0) - "1".charCodeAt(0)));
  const pawnAdvance = role === "pawn" ? SquareSet.fromFile(squareFile(to)) : SquareSet.empty();
  candidates = candidates.intersect(pawnAdvance.union(attacks({ color: opposite(pos.turn), role }, to, pos.board.occupied)));
  let from;
  for (const candidate of candidates) {
    if (pos.dests(candidate, ctx).has(to)) {
      if (defined(from))
        return;
      from = candidate;
    }
  }
  if (!defined(from))
    return;
  return {
    from,
    to,
    promotion
  };
};

export {
  makeSanAndPlay,
  makeSanVariation,
  makeSan,
  parseSan,
  san_exports
};
//# sourceMappingURL=chunk-KZ3PHYFN.js.map
