{
  "version": 3,
  "sources": ["../../../../node_modules/chessops/src/board.ts", "../../../../node_modules/@badrap/result/src/index.ts"],
  "sourcesContent": ["import { SquareSet } from './squareSet.js';\nimport { ByColor, ByRole, Color, COLORS, Piece, Role, ROLES, Square } from './types.js';\n\n/**\n * Piece positions on a board.\n *\n * Properties are sets of squares, like `board.occupied` for all occupied\n * squares, `board[color]` for all pieces of that color, and `board[role]`\n * for all pieces of that role. When modifying the properties directly, take\n * care to keep them consistent.\n */\nexport class Board implements Iterable<[Square, Piece]>, ByRole<SquareSet>, ByColor<SquareSet> {\n  /**\n   * All occupied squares.\n   */\n  occupied: SquareSet;\n  /**\n   * All squares occupied by pieces known to be promoted. This information is\n   * relevant in chess variants like Crazyhouse.\n   */\n  promoted: SquareSet;\n\n  white: SquareSet;\n  black: SquareSet;\n\n  pawn: SquareSet;\n  knight: SquareSet;\n  bishop: SquareSet;\n  rook: SquareSet;\n  queen: SquareSet;\n  king: SquareSet;\n\n  private constructor() {}\n\n  static default(): Board {\n    const board = new Board();\n    board.reset();\n    return board;\n  }\n\n  /**\n   * Resets all pieces to the default starting position for standard chess.\n   */\n  reset(): void {\n    this.occupied = new SquareSet(0xffff, 0xffff_0000);\n    this.promoted = SquareSet.empty();\n    this.white = new SquareSet(0xffff, 0);\n    this.black = new SquareSet(0, 0xffff_0000);\n    this.pawn = new SquareSet(0xff00, 0x00ff_0000);\n    this.knight = new SquareSet(0x42, 0x4200_0000);\n    this.bishop = new SquareSet(0x24, 0x2400_0000);\n    this.rook = new SquareSet(0x81, 0x8100_0000);\n    this.queen = new SquareSet(0x8, 0x0800_0000);\n    this.king = new SquareSet(0x10, 0x1000_0000);\n  }\n\n  static empty(): Board {\n    const board = new Board();\n    board.clear();\n    return board;\n  }\n\n  clear(): void {\n    this.occupied = SquareSet.empty();\n    this.promoted = SquareSet.empty();\n    for (const color of COLORS) this[color] = SquareSet.empty();\n    for (const role of ROLES) this[role] = SquareSet.empty();\n  }\n\n  clone(): Board {\n    const board = new Board();\n    board.occupied = this.occupied;\n    board.promoted = this.promoted;\n    for (const color of COLORS) board[color] = this[color];\n    for (const role of ROLES) board[role] = this[role];\n    return board;\n  }\n\n  getColor(square: Square): Color | undefined {\n    if (this.white.has(square)) return 'white';\n    if (this.black.has(square)) return 'black';\n    return;\n  }\n\n  getRole(square: Square): Role | undefined {\n    for (const role of ROLES) {\n      if (this[role].has(square)) return role;\n    }\n    return;\n  }\n\n  get(square: Square): Piece | undefined {\n    const color = this.getColor(square);\n    if (!color) return;\n    const role = this.getRole(square)!;\n    const promoted = this.promoted.has(square);\n    return { color, role, promoted };\n  }\n\n  /**\n   * Removes and returns the piece from the given `square`, if any.\n   */\n  take(square: Square): Piece | undefined {\n    const piece = this.get(square);\n    if (piece) {\n      this.occupied = this.occupied.without(square);\n      this[piece.color] = this[piece.color].without(square);\n      this[piece.role] = this[piece.role].without(square);\n      if (piece.promoted) this.promoted = this.promoted.without(square);\n    }\n    return piece;\n  }\n\n  /**\n   * Put `piece` onto `square`, potentially replacing an existing piece.\n   * Returns the existing piece, if any.\n   */\n  set(square: Square, piece: Piece): Piece | undefined {\n    const old = this.take(square);\n    this.occupied = this.occupied.with(square);\n    this[piece.color] = this[piece.color].with(square);\n    this[piece.role] = this[piece.role].with(square);\n    if (piece.promoted) this.promoted = this.promoted.with(square);\n    return old;\n  }\n\n  has(square: Square): boolean {\n    return this.occupied.has(square);\n  }\n\n  *[Symbol.iterator](): Iterator<[Square, Piece]> {\n    for (const square of this.occupied) {\n      yield [square, this.get(square)!];\n    }\n  }\n\n  pieces(color: Color, role: Role): SquareSet {\n    return this[color].intersect(this[role]);\n  }\n\n  rooksAndQueens(): SquareSet {\n    return this.rook.union(this.queen);\n  }\n\n  bishopsAndQueens(): SquareSet {\n    return this.bishop.union(this.queen);\n  }\n\n  /**\n   * Finds the unique king of the given `color`, if any.\n   */\n  kingOf(color: Color): Square | undefined {\n    return this.pieces(color, 'king').singleSquare();\n  }\n}\n\nexport const boardEquals = (left: Board, right: Board): boolean =>\n  left.white.equals(right.white)\n  && left.promoted.equals(right.promoted)\n  && ROLES.every(role => left[role].equals(right[role]));\n", "abstract class _Result<T, E extends Error> {\n  protected abstract _chain<X, U extends Error>(\n    ok: (value: T) => Result<X, U>,\n    err: (error: E) => Result<X, U>\n  ): Result<X, U>;\n\n  unwrap(): T;\n  unwrap<U>(ok: (value: T) => U): U;\n  unwrap<U, V>(ok: (value: T) => U, err: (error: E) => V): U | V;\n  unwrap<U>(ok: (value: T) => U, err: (error: E) => U): U;\n  unwrap(ok?: (value: T) => unknown, err?: (error: E) => unknown): unknown {\n    const r = this._chain(\n      value => Result.ok(ok ? ok(value) : value),\n      error => (err ? Result.ok(err(error)) : Result.err(error))\n    );\n    if (r.isErr) {\n      throw r.error;\n    }\n    return r.value;\n  }\n\n  map<U>(ok: (value: T) => U): Result<U, E>;\n  map<U, F extends Error>(\n    ok: (value: T) => U,\n    err: (error: E) => F\n  ): Result<U, F>;\n  map(ok: (value: T) => unknown, err?: (error: E) => Error): Result<unknown> {\n    return this._chain(\n      value => Result.ok(ok(value)),\n      error => Result.err(err ? err(error) : error)\n    );\n  }\n\n  chain<X>(ok: (value: T) => Result<X, E>): Result<X, E>;\n  chain<X>(\n    ok: (value: T) => Result<X, E>,\n    err: (error: E) => Result<X, E>\n  ): Result<X, E>;\n  chain<X, U extends Error>(\n    ok: (value: T) => Result<X, U>,\n    err: (error: E) => Result<X, U>\n  ): Result<X, U>;\n  chain(\n    ok: (value: T) => Result<unknown>,\n    err?: (error: E) => Result<unknown>\n  ): Result<unknown> {\n    return this._chain(ok, err || (error => Result.err(error)));\n  }\n}\n\nclass _Ok<T, E extends Error> extends _Result<T, E> {\n  readonly isOk = true;\n  readonly isErr = false;\n  constructor(readonly value: T) {\n    super();\n  }\n\n  protected _chain<X, U extends Error>(\n    ok: (value: T) => Result<X, U>,\n    _err: (error: E) => Result<X, U>\n  ): Result<X, U> {\n    return ok(this.value);\n  }\n}\n\nclass _Err<T, E extends Error> extends _Result<T, E> {\n  readonly isOk = false;\n  readonly isErr = true;\n  constructor(readonly error: E) {\n    super();\n  }\n\n  protected _chain<X, U extends Error>(\n    _ok: (value: T) => Result<X, U>,\n    err: (error: E) => Result<X, U>\n  ): Result<X, U> {\n    return err(this.error);\n  }\n}\n\nexport namespace Result {\n  export interface Ok<T, E extends Error> extends _Ok<T, E> {}\n  export interface Err<T, E extends Error> extends _Err<T, E> {}\n\n  export function ok<T, E extends Error>(value: T): Result<T, E> {\n    return new _Ok(value);\n  }\n  export function err<E extends Error, T = never>(error?: E): Result<T, E>\n  export function err<E extends Error, T = never>(error: E): Result<T, E> {\n    return new _Err(error || new Error());\n  }\n\n  type U = Result<unknown>;\n  export function all<\n    R0 extends U,\n    R1 extends U,\n    R2 extends U,\n    R3 extends U,\n    R4 extends U,\n    R5 extends U,\n    R6 extends U,\n    R7 extends U,\n    R8 extends U,\n    R9 extends U,\n    R10 extends U,\n    R11 extends U,\n    R12 extends U,\n    R13 extends U,\n    R14 extends U,\n    R15 extends U\n  >(\n    obj: [R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R12, R13, R14, R15]\n  ): Result<\n    [\n      OkType<R0>,\n      OkType<R1>,\n      OkType<R2>,\n      OkType<R3>,\n      OkType<R4>,\n      OkType<R5>,\n      OkType<R6>,\n      OkType<R7>,\n      OkType<R8>,\n      OkType<R9>,\n      OkType<R10>,\n      OkType<R11>,\n      OkType<R12>,\n      OkType<R13>,\n      OkType<R14>,\n      OkType<R15>\n    ],\n    ErrType<\n      | R0\n      | R1\n      | R2\n      | R3\n      | R4\n      | R5\n      | R6\n      | R7\n      | R8\n      | R9\n      | R10\n      | R11\n      | R12\n      | R13\n      | R14\n      | R15\n    >\n  >;\n  export function all<\n    R0 extends U,\n    R1 extends U,\n    R2 extends U,\n    R3 extends U,\n    R4 extends U,\n    R5 extends U,\n    R6 extends U,\n    R7 extends U,\n    R8 extends U,\n    R9 extends U,\n    R10 extends U,\n    R11 extends U,\n    R12 extends U,\n    R13 extends U,\n    R14 extends U\n  >(\n    obj: [R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R12, R13, R14]\n  ): Result<\n    [\n      OkType<R0>,\n      OkType<R1>,\n      OkType<R2>,\n      OkType<R3>,\n      OkType<R4>,\n      OkType<R5>,\n      OkType<R6>,\n      OkType<R7>,\n      OkType<R8>,\n      OkType<R9>,\n      OkType<R10>,\n      OkType<R11>,\n      OkType<R12>,\n      OkType<R13>,\n      OkType<R14>\n    ],\n    ErrType<\n      | R0\n      | R1\n      | R2\n      | R3\n      | R4\n      | R5\n      | R6\n      | R7\n      | R8\n      | R9\n      | R10\n      | R11\n      | R12\n      | R13\n      | R14\n    >\n  >;\n  export function all<\n    R0 extends U,\n    R1 extends U,\n    R2 extends U,\n    R3 extends U,\n    R4 extends U,\n    R5 extends U,\n    R6 extends U,\n    R7 extends U,\n    R8 extends U,\n    R9 extends U,\n    R10 extends U,\n    R11 extends U,\n    R12 extends U,\n    R13 extends U\n  >(\n    obj: [R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R12, R13]\n  ): Result<\n    [\n      OkType<R0>,\n      OkType<R1>,\n      OkType<R2>,\n      OkType<R3>,\n      OkType<R4>,\n      OkType<R5>,\n      OkType<R6>,\n      OkType<R7>,\n      OkType<R8>,\n      OkType<R9>,\n      OkType<R10>,\n      OkType<R11>,\n      OkType<R12>,\n      OkType<R13>\n    ],\n    ErrType<\n      R0 | R1 | R2 | R3 | R4 | R5 | R6 | R7 | R8 | R9 | R10 | R11 | R12 | R13\n    >\n  >;\n  export function all<\n    R0 extends U,\n    R1 extends U,\n    R2 extends U,\n    R3 extends U,\n    R4 extends U,\n    R5 extends U,\n    R6 extends U,\n    R7 extends U,\n    R8 extends U,\n    R9 extends U,\n    R10 extends U,\n    R11 extends U,\n    R12 extends U\n  >(\n    obj: [R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R12]\n  ): Result<\n    [\n      OkType<R0>,\n      OkType<R1>,\n      OkType<R2>,\n      OkType<R3>,\n      OkType<R4>,\n      OkType<R5>,\n      OkType<R6>,\n      OkType<R7>,\n      OkType<R8>,\n      OkType<R9>,\n      OkType<R10>,\n      OkType<R11>\n    ],\n    ErrType<R0 | R1 | R2 | R3 | R4 | R5 | R6 | R7 | R8 | R9 | R10 | R11>\n  >;\n  export function all<\n    R0 extends U,\n    R1 extends U,\n    R2 extends U,\n    R3 extends U,\n    R4 extends U,\n    R5 extends U,\n    R6 extends U,\n    R7 extends U,\n    R8 extends U,\n    R9 extends U,\n    R10 extends U,\n    R11 extends U\n  >(\n    obj: [R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11]\n  ): Result<\n    [\n      OkType<R0>,\n      OkType<R1>,\n      OkType<R2>,\n      OkType<R3>,\n      OkType<R4>,\n      OkType<R5>,\n      OkType<R6>,\n      OkType<R7>,\n      OkType<R8>,\n      OkType<R9>,\n      OkType<R10>,\n      OkType<R11>\n    ],\n    ErrType<R0 | R1 | R2 | R3 | R4 | R5 | R6 | R7 | R8 | R9 | R10 | R11>\n  >;\n  export function all<\n    R0 extends U,\n    R1 extends U,\n    R2 extends U,\n    R3 extends U,\n    R4 extends U,\n    R5 extends U,\n    R6 extends U,\n    R7 extends U,\n    R8 extends U,\n    R9 extends U,\n    R10 extends U\n  >(\n    obj: [R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10]\n  ): Result<\n    [\n      OkType<R0>,\n      OkType<R1>,\n      OkType<R2>,\n      OkType<R3>,\n      OkType<R4>,\n      OkType<R5>,\n      OkType<R6>,\n      OkType<R7>,\n      OkType<R8>,\n      OkType<R9>,\n      OkType<R10>\n    ],\n    ErrType<R0 | R1 | R2 | R3 | R4 | R5 | R6 | R7 | R8 | R9 | R10>\n  >;\n  export function all<\n    R0 extends U,\n    R1 extends U,\n    R2 extends U,\n    R3 extends U,\n    R4 extends U,\n    R5 extends U,\n    R6 extends U,\n    R7 extends U,\n    R8 extends U,\n    R9 extends U\n  >(\n    obj: [R0, R1, R2, R3, R4, R5, R6, R7, R8, R9]\n  ): Result<\n    [\n      OkType<R0>,\n      OkType<R1>,\n      OkType<R2>,\n      OkType<R3>,\n      OkType<R4>,\n      OkType<R5>,\n      OkType<R6>,\n      OkType<R7>,\n      OkType<R8>,\n      OkType<R9>\n    ],\n    ErrType<R0 | R1 | R2 | R3 | R4 | R5 | R6 | R7 | R8 | R9>\n  >;\n  export function all<\n    R0 extends U,\n    R1 extends U,\n    R2 extends U,\n    R3 extends U,\n    R4 extends U,\n    R5 extends U,\n    R6 extends U,\n    R7 extends U,\n    R8 extends U\n  >(\n    obj: [R0, R1, R2, R3, R4, R5, R6, R7, R8]\n  ): Result<\n    [\n      OkType<R0>,\n      OkType<R1>,\n      OkType<R2>,\n      OkType<R3>,\n      OkType<R4>,\n      OkType<R5>,\n      OkType<R6>,\n      OkType<R7>,\n      OkType<R8>\n    ],\n    ErrType<R0 | R1 | R2 | R3 | R4 | R5 | R6 | R7 | R8>\n  >;\n  export function all<\n    R0 extends U,\n    R1 extends U,\n    R2 extends U,\n    R3 extends U,\n    R4 extends U,\n    R5 extends U,\n    R6 extends U,\n    R7 extends U\n  >(\n    obj: [R0, R1, R2, R3, R4, R5, R6, R7]\n  ): Result<\n    [\n      OkType<R0>,\n      OkType<R1>,\n      OkType<R2>,\n      OkType<R3>,\n      OkType<R4>,\n      OkType<R5>,\n      OkType<R6>,\n      OkType<R7>\n    ],\n    ErrType<R0 | R1 | R2 | R3 | R4 | R5 | R6 | R7>\n  >;\n  export function all<\n    R0 extends U,\n    R1 extends U,\n    R2 extends U,\n    R3 extends U,\n    R4 extends U,\n    R5 extends U,\n    R6 extends U\n  >(\n    obj: [R0, R1, R2, R3, R4, R5, R6]\n  ): Result<\n    [\n      OkType<R0>,\n      OkType<R1>,\n      OkType<R2>,\n      OkType<R3>,\n      OkType<R4>,\n      OkType<R5>,\n      OkType<R6>\n    ],\n    ErrType<R0 | R1 | R2 | R3 | R4 | R5 | R6>\n  >;\n  export function all<\n    R0 extends U,\n    R1 extends U,\n    R2 extends U,\n    R3 extends U,\n    R4 extends U,\n    R5 extends U\n  >(\n    obj: [R0, R1, R2, R3, R4, R5]\n  ): Result<\n    [OkType<R0>, OkType<R1>, OkType<R2>, OkType<R3>, OkType<R4>, OkType<R5>],\n    ErrType<R0 | R1 | R2 | R3 | R4 | R5>\n  >;\n  export function all<\n    R0 extends U,\n    R1 extends U,\n    R2 extends U,\n    R3 extends U,\n    R4 extends U\n  >(\n    obj: [R0, R1, R2, R3, R4]\n  ): Result<\n    [OkType<R0>, OkType<R1>, OkType<R2>, OkType<R3>, OkType<R4>],\n    ErrType<R0 | R1 | R2 | R3 | R4>\n  >;\n  export function all<R0 extends U, R1 extends U, R2 extends U, R3 extends U>(\n    obj: [R0, R1, R2, R3]\n  ): Result<\n    [OkType<R0>, OkType<R1>, OkType<R2>, OkType<R3>],\n    ErrType<R0 | R1 | R2 | R3>\n  >;\n  export function all<R0 extends U, R1 extends U, R2 extends U>(\n    obj: [R0, R1, R2]\n  ): Result<[OkType<R0>, OkType<R1>, OkType<R2>], ErrType<R0 | R1 | R2>>;\n  export function all<R0 extends U, R1 extends U>(\n    obj: [R0, R1]\n  ): Result<[OkType<R0>, OkType<R1>], ErrType<R0 | R1>>;\n  export function all<R0 extends U>(\n    obj: [R0]\n  ): Result<[OkType<R0>], ErrType<R0>>;\n  export function all(obj: []): Result<[]>;\n  export function all<T extends Array<U> | Record<string, U>>(\n    obj: T\n  ): Result<\n    { [K in keyof T]: T[K] extends Result<infer I> ? I : never },\n    {\n      [K in keyof T]: T[K] extends Result<unknown, infer E> ? E : never;\n    }[keyof T]\n  >;\n  export function all(obj: unknown): unknown {\n    if (Array.isArray(obj)) {\n      const res = [];\n      for (let i = 0; i < obj.length; i++) {\n        const item = obj[i];\n        if (item.isErr) {\n          return item;\n        }\n        res.push(item.value);\n      }\n      return Result.ok(res);\n    }\n\n    const res: Record<string, unknown> = {};\n    const keys = Object.keys(obj as Record<string, U>);\n    for (let i = 0; i < keys.length; i++) {\n      const item = (obj as Record<string, U>)[keys[i]];\n      if (item.isErr) {\n        return item;\n      }\n      res[keys[i]] = item.value;\n    }\n    return Result.ok(res);\n  }\n}\n\nexport type Result<T, E extends Error = Error> =\n  | Result.Ok<T, E>\n  | Result.Err<T, E>;\n\ntype OkType<R extends Result<unknown>> = R extends Result<infer O> ? O : never;\ntype ErrType<R extends Result<unknown>> = R extends Result<unknown, infer E>\n  ? E\n  : never;\n"],
  "mappings": "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",
  "names": ["_Result", "unwrap", "ok", "err", "r", "this", "_chain", "value", "Result", "error", "isErr", "e", "map", "chain", "_Ok", "constructor", "super", "isOk", "_err", "_Err", "_ok", "Error", "all", "obj", "Array", "isArray", "res", "i", "length", "item", "push", "keys", "Object"]
}
