{
  "version": 3,
  "sources": ["../../../../node_modules/chessops/src/pgn.ts", "../../../../node_modules/chessops/src/variant.ts"],
  "sourcesContent": ["/**\n * Parse, transform and write PGN.\n *\n * ## Parser\n *\n * The parser will interpret any input as a PGN, creating a tree of\n * syntactically valid (but not necessarily legal) moves, skipping any invalid\n * tokens.\n *\n * ```ts\n * import { parsePgn, startingPosition } from 'chessops/pgn';\n * import { parseSan } from 'chessops/san';\n *\n * const pgn = '1. d4 d5 *';\n * const games = parsePgn(pgn);\n * for (const game of games) {\n *   const pos = startingPosition(game.headers).unwrap();\n *   for (const node of game.moves.mainline()) {\n *     const move = parseSan(pos, node.san);\n *     if (!move) break; // Illegal move\n *     pos.play(move);\n *   }\n * }\n * ```\n *\n * ## Streaming parser\n *\n * The module also provides a denial-of-service resistant streaming parser.\n * It can be configured with a budget for reasonable complexity of a single\n * game, fed with chunks of text, and will yield parsed games as they are\n * completed.\n *\n * ```ts\n *\n * import { createReadStream } from 'fs';\n * import { PgnParser } from 'chessops/pgn';\n *\n * const stream = createReadStream('games.pgn', { encoding: 'utf-8' });\n *\n * const parser = new PgnParser((game, err) => {\n *   if (err) {\n *     // Budget exceeded.\n *     stream.destroy(err);\n *   }\n *\n *   // Use game ...\n * });\n *\n * await new Promise<void>(resolve =>\n *   stream\n *     .on('data', (chunk: string) => parser.parse(chunk, { stream: true }))\n *     .on('close', () => {\n *       parser.parse('');\n *       resolve();\n *     })\n * );\n * ```\n *\n * ## Augmenting the game tree\n *\n * You can use `walk` to visit all nodes in the game tree, or `transform`\n * to augment it with user data.\n *\n * Both allow you to provide context. You update the context inside the\n * callback, and it is automatically `clone()`-ed at each fork.\n * In the example below, the current position `pos` is provided as context.\n *\n * ```ts\n * import { transform } from 'chessops/pgn';\n * import { makeFen } from 'chessops/fen';\n * import { parseSan, makeSanAndPlay } from 'chessops/san';\n *\n * const pos = startingPosition(game.headers).unwrap();\n * game.moves = transform(game.moves, pos, (pos, node) => {\n *   const move = parseSan(pos, node.san);\n *   if (!move) {\n *     // Illegal move. Returning undefined cuts off the tree here.\n *     return;\n *   }\n *\n *   const san = makeSanAndPlay(pos, move); // Mutating pos!\n *\n *   return {\n *     ...node, // Keep comments and annotation glyphs\n *     san, // Normalized SAN\n *     fen: makeFen(pos.toSetup()), // Add arbitrary user data to node\n *   };\n * });\n * ```\n *\n * ## Writing\n *\n * Requires each node to at least have a `san` property.\n *\n * ```\n * import { makePgn } from 'chessops/pgn';\n *\n * const rewrittenPgn = makePgn(game);\n * ```\n *\n * @packageDocumentation\n */\nimport { Result } from '@badrap/result';\nimport { IllegalSetup, Position, PositionError } from './chess.js';\nimport { FenError, makeFen, parseFen } from './fen.js';\nimport { Outcome, Rules, Square } from './types.js';\nimport { defined, makeSquare, parseSquare } from './util.js';\nimport { defaultPosition, setupPosition } from './variant.js';\n\nexport interface Game<T> {\n  headers: Map<string, string>;\n  comments?: string[];\n  moves: Node<T>;\n}\n\nexport const defaultGame = <T>(initHeaders: () => Map<string, string> = defaultHeaders): Game<T> => ({\n  headers: initHeaders(),\n  moves: new Node(),\n});\n\nexport class Node<T> {\n  children: ChildNode<T>[] = [];\n\n  *mainlineNodes(): Iterable<ChildNode<T>> {\n    let node: Node<T> = this;\n    while (node.children.length) {\n      const child = node.children[0];\n      yield child;\n      node = child;\n    }\n  }\n\n  *mainline(): Iterable<T> {\n    for (const child of this.mainlineNodes()) yield child.data;\n  }\n\n  end(): Node<T> {\n    let node: Node<T> = this;\n    while (node.children.length) node = node.children[0];\n    return node;\n  }\n}\n\nexport class ChildNode<T> extends Node<T> {\n  constructor(public data: T) {\n    super();\n  }\n}\n\nexport const isChildNode = <T>(node: Node<T>): node is ChildNode<T> => node instanceof ChildNode;\n\nexport const extend = <T>(node: Node<T>, data: T[]): Node<T> => {\n  for (const d of data) {\n    const child = new ChildNode(d);\n    node.children.push(child);\n    node = child;\n  }\n  return node;\n};\n\nexport class Box<T> {\n  constructor(public value: T) {}\n\n  clone(): Box<T> {\n    return new Box(this.value);\n  }\n}\n\nexport const transform = <T, U, C extends { clone(): C }>(\n  node: Node<T>,\n  ctx: C,\n  f: (ctx: C, data: T, childIndex: number) => U | undefined,\n): Node<U> => {\n  const root = new Node<U>();\n  const stack = [\n    {\n      before: node,\n      after: root,\n      ctx,\n    },\n  ];\n  let frame;\n  while ((frame = stack.pop())) {\n    for (let childIndex = 0; childIndex < frame.before.children.length; childIndex++) {\n      const ctx = childIndex < frame.before.children.length - 1 ? frame.ctx.clone() : frame.ctx;\n      const childBefore = frame.before.children[childIndex];\n      const data = f(ctx, childBefore.data, childIndex);\n      if (defined(data)) {\n        const childAfter = new ChildNode(data);\n        frame.after.children.push(childAfter);\n        stack.push({\n          before: childBefore,\n          after: childAfter,\n          ctx,\n        });\n      }\n    }\n  }\n  return root;\n};\n\nexport const walk = <T, C extends { clone(): C }>(\n  node: Node<T>,\n  ctx: C,\n  f: (ctx: C, data: T, childIndex: number) => boolean | void,\n) => {\n  const stack = [{ node, ctx }];\n  let frame;\n  while ((frame = stack.pop())) {\n    for (let childIndex = 0; childIndex < frame.node.children.length; childIndex++) {\n      const ctx = childIndex < frame.node.children.length - 1 ? frame.ctx.clone() : frame.ctx;\n      const child = frame.node.children[childIndex];\n      if (f(ctx, child.data, childIndex) !== false) stack.push({ node: child, ctx });\n    }\n  }\n};\n\nexport interface PgnNodeData {\n  san: string;\n  startingComments?: string[];\n  comments?: string[];\n  nags?: number[];\n}\n\nexport const makeOutcome = (outcome: Outcome | undefined): string => {\n  if (!outcome) return '*';\n  else if (outcome.winner === 'white') return '1-0';\n  else if (outcome.winner === 'black') return '0-1';\n  else return '1/2-1/2';\n};\n\nexport const parseOutcome = (s: string | undefined): Outcome | undefined => {\n  if (s === '1-0' || s === '1–0' || s === '1—0') return { winner: 'white' };\n  else if (s === '0-1' || s === '0–1' || s === '0—1') return { winner: 'black' };\n  else if (s === '1/2-1/2' || s === '1/2–1/2' || s === '1/2—1/2') return { winner: undefined };\n  else return;\n};\n\nconst escapeHeader = (value: string): string => value.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"');\n\nconst safeComment = (comment: string): string => comment.replace(/\\}/g, '');\n\nconst enum MakePgnState {\n  Pre = 0,\n  Sidelines = 1,\n  End = 2,\n}\n\ninterface MakePgnFrame {\n  state: MakePgnState;\n  ply: number;\n  node: ChildNode<PgnNodeData>;\n  sidelines: Iterator<ChildNode<PgnNodeData>>;\n  startsVariation: boolean;\n  inVariation: boolean;\n}\n\nexport const makePgn = (game: Game<PgnNodeData>): string => {\n  const builder = [],\n    tokens = [];\n\n  if (game.headers.size) {\n    for (const [key, value] of game.headers.entries()) {\n      builder.push('[', key, ' \"', escapeHeader(value), '\"]\\n');\n    }\n    builder.push('\\n');\n  }\n\n  for (const comment of game.comments || []) tokens.push('{', safeComment(comment), '}');\n\n  const fen = game.headers.get('FEN');\n  const initialPly = fen\n    ? parseFen(fen).unwrap(\n      setup => (setup.fullmoves - 1) * 2 + (setup.turn === 'white' ? 0 : 1),\n      _ => 0,\n    )\n    : 0;\n\n  const stack: MakePgnFrame[] = [];\n\n  const variations = game.moves.children[Symbol.iterator]();\n  const firstVariation = variations.next();\n  if (!firstVariation.done) {\n    stack.push({\n      state: MakePgnState.Pre,\n      ply: initialPly,\n      node: firstVariation.value,\n      sidelines: variations,\n      startsVariation: false,\n      inVariation: false,\n    });\n  }\n\n  let forceMoveNumber = true;\n  while (stack.length) {\n    const frame = stack[stack.length - 1];\n\n    if (frame.inVariation) {\n      tokens.push(')');\n      frame.inVariation = false;\n      forceMoveNumber = true;\n    }\n\n    switch (frame.state) {\n      case MakePgnState.Pre:\n        for (const comment of frame.node.data.startingComments || []) {\n          tokens.push('{', safeComment(comment), '}');\n          forceMoveNumber = true;\n        }\n        if (forceMoveNumber || frame.ply % 2 === 0) {\n          tokens.push(Math.floor(frame.ply / 2) + 1 + (frame.ply % 2 ? '...' : '.'));\n          forceMoveNumber = false;\n        }\n        tokens.push(frame.node.data.san);\n        for (const nag of frame.node.data.nags || []) {\n          tokens.push('$' + nag);\n          forceMoveNumber = true;\n        }\n        for (const comment of frame.node.data.comments || []) {\n          tokens.push('{', safeComment(comment), '}');\n        }\n        frame.state = MakePgnState.Sidelines; // fall through\n      case MakePgnState.Sidelines: {\n        const child = frame.sidelines.next();\n        if (child.done) {\n          const variations = frame.node.children[Symbol.iterator]();\n          const firstVariation = variations.next();\n          if (!firstVariation.done) {\n            stack.push({\n              state: MakePgnState.Pre,\n              ply: frame.ply + 1,\n              node: firstVariation.value,\n              sidelines: variations,\n              startsVariation: false,\n              inVariation: false,\n            });\n          }\n          frame.state = MakePgnState.End;\n        } else {\n          tokens.push('(');\n          forceMoveNumber = true;\n          stack.push({\n            state: MakePgnState.Pre,\n            ply: frame.ply,\n            node: child.value,\n            sidelines: [][Symbol.iterator](),\n            startsVariation: true,\n            inVariation: false,\n          });\n          frame.inVariation = true;\n        }\n        break;\n      }\n      case MakePgnState.End:\n        stack.pop();\n    }\n  }\n\n  tokens.push(makeOutcome(parseOutcome(game.headers.get('Result'))));\n\n  builder.push(tokens.join(' '), '\\n');\n  return builder.join('');\n};\n\nexport const defaultHeaders = (): Map<string, string> =>\n  new Map([\n    ['Event', '?'],\n    ['Site', '?'],\n    ['Date', '????.??.??'],\n    ['Round', '?'],\n    ['White', '?'],\n    ['Black', '?'],\n    ['Result', '*'],\n  ]);\n\nexport const emptyHeaders = (): Map<string, string> => new Map();\n\nconst BOM = '\\ufeff';\n\nconst isWhitespace = (line: string): boolean => /^\\s*$/.test(line);\n\nconst isCommentLine = (line: string): boolean => line.startsWith('%');\n\nexport interface ParseOptions {\n  stream: boolean;\n}\n\ninterface ParserFrame {\n  parent: Node<PgnNodeData>;\n  root: boolean;\n  node?: ChildNode<PgnNodeData>;\n  startingComments?: string[];\n}\n\nconst enum ParserState {\n  Bom = 0,\n  Pre = 1,\n  Headers = 2,\n  Moves = 3,\n  Comment = 4,\n}\n\nexport class PgnError extends Error {}\n\nexport class PgnParser {\n  private lineBuf: string[] = [];\n\n  private budget: number;\n  private found: boolean;\n  private state: ParserState;\n  private game: Game<PgnNodeData>;\n  private stack: ParserFrame[];\n  private commentBuf: string[];\n\n  constructor(\n    private emitGame: (game: Game<PgnNodeData>, err: PgnError | undefined) => void,\n    private initHeaders: () => Map<string, string> = defaultHeaders,\n    private maxBudget = 1_000_000,\n  ) {\n    this.resetGame();\n    this.state = ParserState.Bom;\n  }\n\n  private resetGame() {\n    this.budget = this.maxBudget;\n    this.found = false;\n    this.state = ParserState.Pre;\n    this.game = defaultGame(this.initHeaders);\n    this.stack = [{ parent: this.game.moves, root: true }];\n    this.commentBuf = [];\n  }\n\n  private consumeBudget(cost: number) {\n    this.budget -= cost;\n    if (this.budget < 0) throw new PgnError('ERR_PGN_BUDGET');\n  }\n\n  parse(data: string, options?: ParseOptions): void {\n    if (this.budget < 0) return;\n    try {\n      let idx = 0;\n      for (;;) {\n        const nlIdx = data.indexOf('\\n', idx);\n        if (nlIdx === -1) {\n          break;\n        }\n        const crIdx = nlIdx > idx && data[nlIdx - 1] === '\\r' ? nlIdx - 1 : nlIdx;\n        this.consumeBudget(nlIdx - idx);\n        this.lineBuf.push(data.slice(idx, crIdx));\n        idx = nlIdx + 1;\n        this.handleLine();\n      }\n      this.consumeBudget(data.length - idx);\n      this.lineBuf.push(data.slice(idx));\n\n      if (!options?.stream) {\n        this.handleLine();\n        this.emit(undefined);\n      }\n    } catch (err: unknown) {\n      this.emit(err as PgnError);\n    }\n  }\n\n  private handleLine() {\n    let freshLine = true;\n    let line = this.lineBuf.join('');\n    this.lineBuf = [];\n\n    continuedLine: for (;;) {\n      switch (this.state) {\n        case ParserState.Bom:\n          if (line.startsWith(BOM)) line = line.slice(BOM.length);\n          this.state = ParserState.Pre; // fall through\n        case ParserState.Pre:\n          if (isWhitespace(line) || isCommentLine(line)) return;\n          this.found = true;\n          this.state = ParserState.Headers; // fall through\n        case ParserState.Headers: {\n          if (isCommentLine(line)) return;\n          let moreHeaders = true;\n          while (moreHeaders) {\n            moreHeaders = false;\n            line = line.replace(\n              /^\\s*\\[([A-Za-z0-9][A-Za-z0-9_+#=:-]*)\\s+\"((?:[^\"\\\\]|\\\\\"|\\\\\\\\)*)\"\\]/,\n              (_match, headerName, headerValue) => {\n                this.consumeBudget(200);\n                this.handleHeader(headerName, headerValue.replace(/\\\\\"/g, '\"').replace(/\\\\\\\\/g, '\\\\'));\n                moreHeaders = true;\n                freshLine = false;\n                return '';\n              },\n            );\n          }\n          if (isWhitespace(line)) return;\n          this.state = ParserState.Moves; // fall through\n        }\n        case ParserState.Moves: {\n          if (freshLine) {\n            if (isCommentLine(line)) return;\n            if (isWhitespace(line)) return this.emit(undefined);\n          }\n          const tokenRegex =\n            /(?:[NBKRQ]?[a-h]?[1-8]?[-x]?[a-h][1-8](?:=?[nbrqkNBRQK])?|[pnbrqkPNBRQK]?@[a-h][1-8]|[O0o][-–—][O0o](?:[-–—][O0o])?)[+#]?|--|Z0|0000|@@@@|{|;|\\$\\d{1,4}|[?!]{1,2}|\\(|\\)|\\*|1[-–—]0|0[-–—]1|1\\/2[-–—]1\\/2/g;\n          let match;\n          while ((match = tokenRegex.exec(line))) {\n            const frame = this.stack[this.stack.length - 1];\n            let token = match[0];\n            if (token === ';') return;\n            else if (token.startsWith('$')) this.handleNag(parseInt(token.slice(1), 10));\n            else if (token === '!') this.handleNag(1);\n            else if (token === '?') this.handleNag(2);\n            else if (token === '!!') this.handleNag(3);\n            else if (token === '??') this.handleNag(4);\n            else if (token === '!?') this.handleNag(5);\n            else if (token === '?!') this.handleNag(6);\n            else if (\n              token === '1-0' || token === '1–0' || token === '1—0'\n              || token === '0-1' || token === '0–1' || token === '0—1'\n              || token === '1/2-1/2' || token === '1/2–1/2' || token === '1/2—1/2'\n              || token === '*'\n            ) {\n              if (this.stack.length === 1 && token !== '*') this.handleHeader('Result', token);\n            } else if (token === '(') {\n              this.consumeBudget(100);\n              this.stack.push({ parent: frame.parent, root: false });\n            } else if (token === ')') {\n              if (this.stack.length > 1) this.stack.pop();\n            } else if (token === '{') {\n              const openIndex = tokenRegex.lastIndex;\n              const beginIndex = line[openIndex] === ' ' ? openIndex + 1 : openIndex;\n              line = line.slice(beginIndex);\n              this.state = ParserState.Comment;\n              continue continuedLine;\n            } else {\n              this.consumeBudget(100);\n              if (token.startsWith('O') || token.startsWith('0') || token.startsWith('o')) {\n                token = token.replace(/[0o]/g, 'O').replace(/[–—]/g, '-');\n              } else if (token === 'Z0' || token === '0000' || token === '@@@@') token = '--';\n\n              if (frame.node) frame.parent = frame.node;\n              frame.node = new ChildNode({\n                san: token,\n                startingComments: frame.startingComments,\n              });\n              frame.startingComments = undefined;\n              frame.root = false;\n              frame.parent.children.push(frame.node);\n            }\n          }\n          return;\n        }\n        case ParserState.Comment: {\n          const closeIndex = line.indexOf('}');\n          if (closeIndex === -1) {\n            this.commentBuf.push(line);\n            return;\n          } else {\n            const endIndex = closeIndex > 0 && line[closeIndex - 1] === ' ' ? closeIndex - 1 : closeIndex;\n            this.commentBuf.push(line.slice(0, endIndex));\n            this.handleComment();\n            line = line.slice(closeIndex);\n            this.state = ParserState.Moves;\n            freshLine = false;\n          }\n        }\n      }\n    }\n  }\n\n  private handleHeader(name: string, value: string) {\n    this.game.headers.set(name, name === 'Result' ? makeOutcome(parseOutcome(value)) : value);\n  }\n\n  private handleNag(nag: number) {\n    this.consumeBudget(50);\n    const frame = this.stack[this.stack.length - 1];\n    if (frame.node) {\n      frame.node.data.nags ||= [];\n      frame.node.data.nags.push(nag);\n    }\n  }\n\n  private handleComment() {\n    this.consumeBudget(100);\n    const frame = this.stack[this.stack.length - 1];\n    const comment = this.commentBuf.join('\\n');\n    this.commentBuf = [];\n    if (frame.node) {\n      frame.node.data.comments ||= [];\n      frame.node.data.comments.push(comment);\n    } else if (frame.root) {\n      this.game.comments ||= [];\n      this.game.comments.push(comment);\n    } else {\n      frame.startingComments ||= [];\n      frame.startingComments.push(comment);\n    }\n  }\n\n  private emit(err: PgnError | undefined) {\n    if (this.state === ParserState.Comment) this.handleComment();\n    if (err) return this.emitGame(this.game, err);\n    if (this.found) this.emitGame(this.game, undefined);\n    this.resetGame();\n  }\n}\n\nexport const parsePgn = (pgn: string, initHeaders: () => Map<string, string> = defaultHeaders): Game<PgnNodeData>[] => {\n  const games: Game<PgnNodeData>[] = [];\n  new PgnParser(game => games.push(game), initHeaders, NaN).parse(pgn);\n  return games;\n};\n\nexport const parseVariant = (variant: string | undefined): Rules | undefined => {\n  switch ((variant || 'chess').toLowerCase()) {\n    case 'chess':\n    case 'chess960':\n    case 'chess 960':\n    case 'standard':\n    case 'from position':\n    case 'classical':\n    case 'normal':\n    case 'fischerandom': // Cute Chess\n    case 'fischerrandom':\n    case 'fischer random':\n    case 'wild/0':\n    case 'wild/1':\n    case 'wild/2':\n    case 'wild/3':\n    case 'wild/4':\n    case 'wild/5':\n    case 'wild/6':\n    case 'wild/7':\n    case 'wild/8':\n    case 'wild/8a':\n      return 'chess';\n    case 'crazyhouse':\n    case 'crazy house':\n    case 'house':\n    case 'zh':\n      return 'crazyhouse';\n    case 'king of the hill':\n    case 'koth':\n    case 'kingofthehill':\n      return 'kingofthehill';\n    case 'three-check':\n    case 'three check':\n    case 'threecheck':\n    case 'three check chess':\n    case '3-check':\n    case '3 check':\n    case '3check':\n      return '3check';\n    case 'antichess':\n    case 'anti chess':\n    case 'anti':\n      return 'antichess';\n    case 'atomic':\n    case 'atom':\n    case 'atomic chess':\n      return 'atomic';\n    case 'horde':\n    case 'horde chess':\n      return 'horde';\n    case 'racing kings':\n    case 'racingkings':\n    case 'racing':\n    case 'race':\n      return 'racingkings';\n    default:\n      return;\n  }\n};\n\nexport const makeVariant = (rules: Rules): string | undefined => {\n  switch (rules) {\n    case 'chess':\n      return;\n    case 'crazyhouse':\n      return 'Crazyhouse';\n    case 'racingkings':\n      return 'Racing Kings';\n    case 'horde':\n      return 'Horde';\n    case 'atomic':\n      return 'Atomic';\n    case 'antichess':\n      return 'Antichess';\n    case '3check':\n      return 'Three-check';\n    case 'kingofthehill':\n      return 'King of the Hill';\n  }\n};\n\nexport const startingPosition = (headers: Map<string, string>): Result<Position, FenError | PositionError> => {\n  const rules = parseVariant(headers.get('Variant'));\n  if (!rules) return Result.err(new PositionError(IllegalSetup.Variant));\n  const fen = headers.get('FEN');\n  if (fen) return parseFen(fen).chain(setup => setupPosition(rules, setup));\n  else return Result.ok(defaultPosition(rules));\n};\n\nexport const setStartingPosition = (headers: Map<string, string>, pos: Position) => {\n  const variant = makeVariant(pos.rules);\n  if (variant) headers.set('Variant', variant);\n  else headers.delete('Variant');\n\n  const fen = makeFen(pos.toSetup());\n  const defaultFen = makeFen(defaultPosition(pos.rules).toSetup());\n  if (fen !== defaultFen) headers.set('FEN', fen);\n  else headers.delete('FEN');\n};\n\nexport type CommentShapeColor = 'green' | 'red' | 'yellow' | 'blue';\n\nexport interface CommentShape {\n  color: CommentShapeColor;\n  from: Square;\n  to: Square;\n}\n\nexport type EvaluationPawns = { pawns: number; depth?: number };\nexport type EvaluationMate = { mate: number; depth?: number };\nexport type Evaluation = EvaluationPawns | EvaluationMate;\n\nexport const isPawns = (ev: Evaluation): ev is EvaluationPawns => 'pawns' in ev;\nexport const isMate = (ev: Evaluation): ev is EvaluationMate => 'mate' in ev;\n\nexport interface Comment {\n  text: string;\n  shapes: CommentShape[];\n  clock?: number;\n  emt?: number;\n  evaluation?: Evaluation;\n}\n\nconst makeClk = (seconds: number): string => {\n  seconds = Math.max(0, seconds);\n  const hours = Math.floor(seconds / 3600);\n  const minutes = Math.floor((seconds % 3600) / 60);\n  seconds = (seconds % 3600) % 60;\n  return `${hours}:${minutes.toString().padStart(2, '0')}:${\n    seconds.toLocaleString('en', {\n      minimumIntegerDigits: 2,\n      maximumFractionDigits: 3,\n    })\n  }`;\n};\n\nconst makeCommentShapeColor = (color: CommentShapeColor): 'G' | 'R' | 'Y' | 'B' => {\n  switch (color) {\n    case 'green':\n      return 'G';\n    case 'red':\n      return 'R';\n    case 'yellow':\n      return 'Y';\n    case 'blue':\n      return 'B';\n  }\n};\n\nfunction parseCommentShapeColor(str: 'G' | 'R' | 'Y' | 'B'): CommentShapeColor;\nfunction parseCommentShapeColor(str: string): CommentShapeColor | undefined;\nfunction parseCommentShapeColor(str: string): CommentShapeColor | undefined {\n  switch (str) {\n    case 'G':\n      return 'green';\n    case 'R':\n      return 'red';\n    case 'Y':\n      return 'yellow';\n    case 'B':\n      return 'blue';\n    default:\n      return;\n  }\n}\n\nconst makeCommentShape = (shape: CommentShape): string =>\n  shape.to === shape.from\n    ? `${makeCommentShapeColor(shape.color)}${makeSquare(shape.to)}`\n    : `${makeCommentShapeColor(shape.color)}${makeSquare(shape.from)}${makeSquare(shape.to)}`;\n\nconst parseCommentShape = (str: string): CommentShape | undefined => {\n  const color = parseCommentShapeColor(str.slice(0, 1));\n  const from = parseSquare(str.slice(1, 3));\n  const to = parseSquare(str.slice(3, 5));\n  if (!color || !defined(from)) return;\n  if (str.length === 3) return { color, from, to: from };\n  if (str.length === 5 && defined(to)) return { color, from, to };\n  return;\n};\n\nconst makeEval = (ev: Evaluation): string => {\n  const str = isMate(ev) ? '#' + ev.mate : ev.pawns.toFixed(2);\n  return defined(ev.depth) ? str + ',' + ev.depth : str;\n};\n\nexport const makeComment = (comment: Partial<Comment>): string => {\n  const builder = [];\n  if (defined(comment.text)) builder.push(comment.text);\n  const circles = (comment.shapes || []).filter(shape => shape.to === shape.from).map(makeCommentShape);\n  if (circles.length) builder.push(`[%csl ${circles.join(',')}]`);\n  const arrows = (comment.shapes || []).filter(shape => shape.to !== shape.from).map(makeCommentShape);\n  if (arrows.length) builder.push(`[%cal ${arrows.join(',')}]`);\n  if (comment.evaluation) builder.push(`[%eval ${makeEval(comment.evaluation)}]`);\n  if (defined(comment.emt)) builder.push(`[%emt ${makeClk(comment.emt)}]`);\n  if (defined(comment.clock)) builder.push(`[%clk ${makeClk(comment.clock)}]`);\n  return builder.join(' ');\n};\n\nexport const parseComment = (comment: string): Comment => {\n  let emt, clock, evaluation;\n  const shapes: CommentShape[] = [];\n  const text = comment\n    .replace(\n      /\\s?\\[%(emt|clk)\\s(\\d{1,5}):(\\d{1,2}):(\\d{1,2}(?:\\.\\d{0,3})?)\\]\\s?/g,\n      (_, annotation, hours, minutes, seconds) => {\n        const value = parseInt(hours, 10) * 3600 + parseInt(minutes, 10) * 60 + parseFloat(seconds);\n        if (annotation === 'emt') emt = value;\n        else if (annotation === 'clk') clock = value;\n        return '  ';\n      },\n    )\n    .replace(\n      /\\s?\\[%(?:csl|cal)\\s([RGYB][a-h][1-8](?:[a-h][1-8])?(?:,[RGYB][a-h][1-8](?:[a-h][1-8])?)*)\\]\\s?/g,\n      (_, arrows) => {\n        for (const arrow of arrows.split(',')) {\n          shapes.push(parseCommentShape(arrow)!);\n        }\n        return '  ';\n      },\n    )\n    .replace(\n      /\\s?\\[%eval\\s(?:#([+-]?\\d{1,5})|([+-]?(?:\\d{1,5}|\\d{0,5}\\.\\d{1,2})))(?:,(\\d{1,5}))?\\]\\s?/g,\n      (_, mate, pawns, d) => {\n        const depth = d && parseInt(d, 10);\n        evaluation = mate ? { mate: parseInt(mate, 10), depth } : { pawns: parseFloat(pawns), depth };\n        return '  ';\n      },\n    )\n    .trim();\n  return {\n    text,\n    shapes,\n    emt,\n    clock,\n    evaluation,\n  };\n};\n", "import { Result } from '@badrap/result';\nimport { between, kingAttacks, pawnAttacks } from './attacks.js';\nimport { Board } from './board.js';\nimport {\n  Castles,\n  castlingSide,\n  Chess,\n  Context,\n  equalsIgnoreMoves,\n  IllegalSetup,\n  isImpossibleCheck,\n  isStandardMaterialSide,\n  normalizeMove,\n  Position,\n  PositionError,\n  pseudoDests,\n} from './chess.js';\nimport { Material, MaterialSide, RemainingChecks, Setup } from './setup.js';\nimport { SquareSet } from './squareSet.js';\nimport { Color, COLORS, Outcome, Piece, Rules, Square } from './types.js';\nimport { defined, opposite } from './util.js';\n\nexport {\n  Castles,\n  castlingSide,\n  Chess,\n  Context,\n  equalsIgnoreMoves,\n  IllegalSetup,\n  isImpossibleCheck,\n  normalizeMove,\n  Position,\n  PositionError,\n};\n\nexport class Crazyhouse extends Position {\n  private constructor() {\n    super('crazyhouse');\n  }\n\n  reset() {\n    super.reset();\n    this.pockets = Material.empty();\n  }\n\n  protected setupUnchecked(setup: Setup) {\n    super.setupUnchecked(setup);\n    this.board.promoted = setup.board.promoted\n      .intersect(setup.board.occupied)\n      .diff(setup.board.king)\n      .diff(setup.board.pawn);\n    this.pockets = setup.pockets ? setup.pockets.clone() : Material.empty();\n  }\n\n  static default(): Crazyhouse {\n    const pos = new this();\n    pos.reset();\n    return pos;\n  }\n\n  static fromSetup(setup: Setup): Result<Crazyhouse, PositionError> {\n    const pos = new this();\n    pos.setupUnchecked(setup);\n    return pos.validate().map(_ => pos);\n  }\n\n  clone(): Crazyhouse {\n    return super.clone() as Crazyhouse;\n  }\n\n  protected validate(): Result<undefined, PositionError> {\n    return super.validate().chain(_ => {\n      if (this.pockets?.count('king')) {\n        return Result.err(new PositionError(IllegalSetup.Kings));\n      }\n      if ((this.pockets?.size() || 0) + this.board.occupied.size() > 64) {\n        return Result.err(new PositionError(IllegalSetup.Variant));\n      }\n      return Result.ok(undefined);\n    });\n  }\n\n  hasInsufficientMaterial(color: Color): boolean {\n    // No material can leave the game, but we can easily check this for\n    // custom positions.\n    if (!this.pockets) return super.hasInsufficientMaterial(color);\n    return (\n      this.board.occupied.size() + this.pockets.size() <= 3\n      && this.board.pawn.isEmpty()\n      && this.board.promoted.isEmpty()\n      && this.board.rooksAndQueens().isEmpty()\n      && this.pockets.count('pawn') <= 0\n      && this.pockets.count('rook') <= 0\n      && this.pockets.count('queen') <= 0\n    );\n  }\n\n  dropDests(ctx?: Context): SquareSet {\n    const mask = this.board.occupied\n      .complement()\n      .intersect(\n        this.pockets?.[this.turn].hasNonPawns()\n          ? SquareSet.full()\n          : this.pockets?.[this.turn].hasPawns()\n          ? SquareSet.backranks().complement()\n          : SquareSet.empty(),\n      );\n\n    ctx = ctx || this.ctx();\n    if (defined(ctx.king) && ctx.checkers.nonEmpty()) {\n      const checker = ctx.checkers.singleSquare();\n      if (!defined(checker)) return SquareSet.empty();\n      return mask.intersect(between(checker, ctx.king));\n    } else return mask;\n  }\n}\n\nexport class Atomic extends Position {\n  private constructor() {\n    super('atomic');\n  }\n\n  static default(): Atomic {\n    const pos = new this();\n    pos.reset();\n    return pos;\n  }\n\n  static fromSetup(setup: Setup): Result<Atomic, PositionError> {\n    const pos = new this();\n    pos.setupUnchecked(setup);\n    return pos.validate().map(_ => pos);\n  }\n\n  clone(): Atomic {\n    return super.clone() as Atomic;\n  }\n\n  protected validate(): Result<undefined, PositionError> {\n    // Like chess, but allow our king to be missing.\n    if (this.board.occupied.isEmpty()) return Result.err(new PositionError(IllegalSetup.Empty));\n    if (this.board.king.size() > 2) return Result.err(new PositionError(IllegalSetup.Kings));\n    const otherKing = this.board.kingOf(opposite(this.turn));\n    if (!defined(otherKing)) return Result.err(new PositionError(IllegalSetup.Kings));\n    if (this.kingAttackers(otherKing, this.turn, this.board.occupied).nonEmpty()) {\n      return Result.err(new PositionError(IllegalSetup.OppositeCheck));\n    }\n    if (SquareSet.backranks().intersects(this.board.pawn)) {\n      return Result.err(new PositionError(IllegalSetup.PawnsOnBackrank));\n    }\n    return Result.ok(undefined);\n  }\n\n  kingAttackers(square: Square, attacker: Color, occupied: SquareSet): SquareSet {\n    const attackerKings = this.board.pieces(attacker, 'king');\n    if (attackerKings.isEmpty() || kingAttacks(square).intersects(attackerKings)) {\n      return SquareSet.empty();\n    }\n    return super.kingAttackers(square, attacker, occupied);\n  }\n\n  protected playCaptureAt(square: Square, captured: Piece): void {\n    super.playCaptureAt(square, captured);\n    this.board.take(square);\n    for (const explode of kingAttacks(square).intersect(this.board.occupied).diff(this.board.pawn)) {\n      const piece = this.board.take(explode);\n      if (piece?.role === 'rook') this.castles.discardRook(explode);\n      if (piece?.role === 'king') this.castles.discardColor(piece.color);\n    }\n  }\n\n  hasInsufficientMaterial(color: Color): boolean {\n    // Remaining material does not matter if the enemy king is already\n    // exploded.\n    if (this.board.pieces(opposite(color), 'king').isEmpty()) return false;\n\n    // Bare king cannot mate.\n    if (this.board[color].diff(this.board.king).isEmpty()) return true;\n\n    // As long as the enemy king is not alone, there is always a chance their\n    // own pieces explode next to it.\n    if (this.board[opposite(color)].diff(this.board.king).nonEmpty()) {\n      // Unless there are only bishops that cannot explode each other.\n      if (this.board.occupied.equals(this.board.bishop.union(this.board.king))) {\n        if (!this.board.bishop.intersect(this.board.white).intersects(SquareSet.darkSquares())) {\n          return !this.board.bishop.intersect(this.board.black).intersects(SquareSet.lightSquares());\n        }\n        if (!this.board.bishop.intersect(this.board.white).intersects(SquareSet.lightSquares())) {\n          return !this.board.bishop.intersect(this.board.black).intersects(SquareSet.darkSquares());\n        }\n      }\n      return false;\n    }\n\n    // Queen or pawn (future queen) can give mate against bare king.\n    if (this.board.queen.nonEmpty() || this.board.pawn.nonEmpty()) return false;\n\n    // Single knight, bishop or rook cannot mate against bare king.\n    if (this.board.knight.union(this.board.bishop).union(this.board.rook).size() === 1) return true;\n\n    // If only knights, more than two are required to mate bare king.\n    if (this.board.occupied.equals(this.board.knight.union(this.board.king))) {\n      return this.board.knight.size() <= 2;\n    }\n\n    return false;\n  }\n\n  dests(square: Square, ctx?: Context): SquareSet {\n    ctx = ctx || this.ctx();\n    let dests = SquareSet.empty();\n    for (const to of pseudoDests(this, square, ctx)) {\n      const after = this.clone();\n      after.play({ from: square, to });\n      const ourKing = after.board.kingOf(this.turn);\n      if (\n        defined(ourKing)\n        && (!defined(after.board.kingOf(after.turn))\n          || after.kingAttackers(ourKing, after.turn, after.board.occupied).isEmpty())\n      ) {\n        dests = dests.with(to);\n      }\n    }\n    return dests;\n  }\n\n  isVariantEnd(): boolean {\n    return !!this.variantOutcome();\n  }\n\n  variantOutcome(_ctx?: Context): Outcome | undefined {\n    for (const color of COLORS) {\n      if (this.board.pieces(color, 'king').isEmpty()) return { winner: opposite(color) };\n    }\n    return;\n  }\n}\n\nexport class Antichess extends Position {\n  private constructor() {\n    super('antichess');\n  }\n\n  reset() {\n    super.reset();\n    this.castles = Castles.empty();\n  }\n\n  protected setupUnchecked(setup: Setup) {\n    super.setupUnchecked(setup);\n    this.castles = Castles.empty();\n  }\n\n  static default(): Antichess {\n    const pos = new this();\n    pos.reset();\n    return pos;\n  }\n\n  static fromSetup(setup: Setup): Result<Antichess, PositionError> {\n    const pos = new this();\n    pos.setupUnchecked(setup);\n    return pos.validate().map(_ => pos);\n  }\n\n  clone(): Antichess {\n    return super.clone() as Antichess;\n  }\n\n  protected validate(): Result<undefined, PositionError> {\n    if (this.board.occupied.isEmpty()) return Result.err(new PositionError(IllegalSetup.Empty));\n    if (SquareSet.backranks().intersects(this.board.pawn)) {\n      return Result.err(new PositionError(IllegalSetup.PawnsOnBackrank));\n    }\n    return Result.ok(undefined);\n  }\n\n  kingAttackers(_square: Square, _attacker: Color, _occupied: SquareSet): SquareSet {\n    return SquareSet.empty();\n  }\n\n  ctx(): Context {\n    const ctx = super.ctx();\n    if (\n      defined(this.epSquare)\n      && pawnAttacks(opposite(this.turn), this.epSquare).intersects(this.board.pieces(this.turn, 'pawn'))\n    ) {\n      ctx.mustCapture = true;\n      return ctx;\n    }\n    const enemy = this.board[opposite(this.turn)];\n    for (const from of this.board[this.turn]) {\n      if (pseudoDests(this, from, ctx).intersects(enemy)) {\n        ctx.mustCapture = true;\n        return ctx;\n      }\n    }\n    return ctx;\n  }\n\n  dests(square: Square, ctx?: Context): SquareSet {\n    ctx = ctx || this.ctx();\n    const dests = pseudoDests(this, square, ctx);\n    const enemy = this.board[opposite(this.turn)];\n    return dests.intersect(\n      ctx.mustCapture\n        ? defined(this.epSquare) && this.board.getRole(square) === 'pawn'\n          ? enemy.with(this.epSquare)\n          : enemy\n        : SquareSet.full(),\n    );\n  }\n\n  hasInsufficientMaterial(color: Color): boolean {\n    if (this.board[color].isEmpty()) return false;\n    if (this.board[opposite(color)].isEmpty()) return true;\n    if (this.board.occupied.equals(this.board.bishop)) {\n      const weSomeOnLight = this.board[color].intersects(SquareSet.lightSquares());\n      const weSomeOnDark = this.board[color].intersects(SquareSet.darkSquares());\n      const theyAllOnDark = this.board[opposite(color)].isDisjoint(SquareSet.lightSquares());\n      const theyAllOnLight = this.board[opposite(color)].isDisjoint(SquareSet.darkSquares());\n      return (weSomeOnLight && theyAllOnDark) || (weSomeOnDark && theyAllOnLight);\n    }\n    if (this.board.occupied.equals(this.board.knight) && this.board.occupied.size() === 2) {\n      return (\n        (this.board.white.intersects(SquareSet.lightSquares())\n          !== this.board.black.intersects(SquareSet.darkSquares()))\n          !== (this.turn === color)\n      );\n    }\n    return false;\n  }\n\n  isVariantEnd(): boolean {\n    return this.board[this.turn].isEmpty();\n  }\n\n  variantOutcome(ctx?: Context): Outcome | undefined {\n    ctx = ctx || this.ctx();\n    if (ctx.variantEnd || this.isStalemate(ctx)) {\n      return { winner: this.turn };\n    }\n    return;\n  }\n}\n\nexport class KingOfTheHill extends Position {\n  private constructor() {\n    super('kingofthehill');\n  }\n\n  static default(): KingOfTheHill {\n    const pos = new this();\n    pos.reset();\n    return pos;\n  }\n\n  static fromSetup(setup: Setup): Result<KingOfTheHill, PositionError> {\n    const pos = new this();\n    pos.setupUnchecked(setup);\n    return pos.validate().map(_ => pos);\n  }\n\n  clone(): KingOfTheHill {\n    return super.clone() as KingOfTheHill;\n  }\n\n  hasInsufficientMaterial(_color: Color): boolean {\n    return false;\n  }\n\n  isVariantEnd(): boolean {\n    return this.board.king.intersects(SquareSet.center());\n  }\n\n  variantOutcome(_ctx?: Context): Outcome | undefined {\n    for (const color of COLORS) {\n      if (this.board.pieces(color, 'king').intersects(SquareSet.center())) return { winner: color };\n    }\n    return;\n  }\n}\n\nexport class ThreeCheck extends Position {\n  private constructor() {\n    super('3check');\n  }\n\n  reset() {\n    super.reset();\n    this.remainingChecks = RemainingChecks.default();\n  }\n\n  protected setupUnchecked(setup: Setup) {\n    super.setupUnchecked(setup);\n    this.remainingChecks = setup.remainingChecks?.clone() || RemainingChecks.default();\n  }\n\n  static default(): ThreeCheck {\n    const pos = new this();\n    pos.reset();\n    return pos;\n  }\n\n  static fromSetup(setup: Setup): Result<ThreeCheck, PositionError> {\n    const pos = new this();\n    pos.setupUnchecked(setup);\n    return pos.validate().map(_ => pos);\n  }\n\n  clone(): ThreeCheck {\n    return super.clone() as ThreeCheck;\n  }\n\n  hasInsufficientMaterial(color: Color): boolean {\n    return this.board.pieces(color, 'king').equals(this.board[color]);\n  }\n\n  isVariantEnd(): boolean {\n    return !!this.remainingChecks && (this.remainingChecks.white <= 0 || this.remainingChecks.black <= 0);\n  }\n\n  variantOutcome(_ctx?: Context): Outcome | undefined {\n    if (this.remainingChecks) {\n      for (const color of COLORS) {\n        if (this.remainingChecks[color] <= 0) return { winner: color };\n      }\n    }\n    return;\n  }\n}\n\nconst racingKingsBoard = (): Board => {\n  const board = Board.empty();\n  board.occupied = new SquareSet(0xffff, 0);\n  board.promoted = SquareSet.empty();\n  board.white = new SquareSet(0xf0f0, 0);\n  board.black = new SquareSet(0x0f0f, 0);\n  board.pawn = SquareSet.empty();\n  board.knight = new SquareSet(0x1818, 0);\n  board.bishop = new SquareSet(0x2424, 0);\n  board.rook = new SquareSet(0x4242, 0);\n  board.queen = new SquareSet(0x0081, 0);\n  board.king = new SquareSet(0x8100, 0);\n  return board;\n};\n\nexport class RacingKings extends Position {\n  private constructor() {\n    super('racingkings');\n  }\n\n  reset() {\n    this.board = racingKingsBoard();\n    this.pockets = undefined;\n    this.turn = 'white';\n    this.castles = Castles.empty();\n    this.epSquare = undefined;\n    this.remainingChecks = undefined;\n    this.halfmoves = 0;\n    this.fullmoves = 1;\n  }\n\n  setupUnchecked(setup: Setup) {\n    super.setupUnchecked(setup);\n    this.castles = Castles.empty();\n  }\n\n  static default(): RacingKings {\n    const pos = new this();\n    pos.reset();\n    return pos;\n  }\n\n  static fromSetup(setup: Setup): Result<RacingKings, PositionError> {\n    const pos = new this();\n    pos.setupUnchecked(setup);\n    return pos.validate().map(_ => pos);\n  }\n\n  clone(): RacingKings {\n    return super.clone() as RacingKings;\n  }\n\n  protected validate(): Result<undefined, PositionError> {\n    if (this.isCheck() || this.board.pawn.nonEmpty()) return Result.err(new PositionError(IllegalSetup.Variant));\n    return super.validate();\n  }\n\n  dests(square: Square, ctx?: Context): SquareSet {\n    ctx = ctx || this.ctx();\n\n    // Kings cannot give check.\n    if (square === ctx.king) return super.dests(square, ctx);\n\n    // Do not allow giving check.\n    let dests = SquareSet.empty();\n    for (const to of super.dests(square, ctx)) {\n      // Valid, because there are no promotions (or even pawns).\n      const move = { from: square, to };\n      const after = this.clone();\n      after.play(move);\n      if (!after.isCheck()) dests = dests.with(to);\n    }\n    return dests;\n  }\n\n  hasInsufficientMaterial(_color: Color): boolean {\n    return false;\n  }\n\n  isVariantEnd(): boolean {\n    const goal = SquareSet.fromRank(7);\n    const inGoal = this.board.king.intersect(goal);\n    if (inGoal.isEmpty()) return false;\n    if (this.turn === 'white' || inGoal.intersects(this.board.black)) return true;\n\n    // White has reached the backrank. Check if black can catch up.\n    const blackKing = this.board.kingOf('black');\n    if (defined(blackKing)) {\n      const occ = this.board.occupied.without(blackKing);\n      for (const target of kingAttacks(blackKing).intersect(goal).diff(this.board.black)) {\n        if (this.kingAttackers(target, 'white', occ).isEmpty()) return false;\n      }\n    }\n    return true;\n  }\n\n  variantOutcome(ctx?: Context): Outcome | undefined {\n    if (ctx ? !ctx.variantEnd : !this.isVariantEnd()) return;\n    const goal = SquareSet.fromRank(7);\n    const blackInGoal = this.board.pieces('black', 'king').intersects(goal);\n    const whiteInGoal = this.board.pieces('white', 'king').intersects(goal);\n    if (blackInGoal && !whiteInGoal) return { winner: 'black' };\n    if (whiteInGoal && !blackInGoal) return { winner: 'white' };\n    return { winner: undefined };\n  }\n}\n\nconst hordeBoard = (): Board => {\n  const board = Board.empty();\n  board.occupied = new SquareSet(0xffff_ffff, 0xffff_0066);\n  board.promoted = SquareSet.empty();\n  board.white = new SquareSet(0xffff_ffff, 0x0000_0066);\n  board.black = new SquareSet(0, 0xffff_0000);\n  board.pawn = new SquareSet(0xffff_ffff, 0x00ff_0066);\n  board.knight = new SquareSet(0, 0x4200_0000);\n  board.bishop = new SquareSet(0, 0x2400_0000);\n  board.rook = new SquareSet(0, 0x8100_0000);\n  board.queen = new SquareSet(0, 0x0800_0000);\n  board.king = new SquareSet(0, 0x1000_0000);\n  return board;\n};\n\nexport class Horde extends Position {\n  private constructor() {\n    super('horde');\n  }\n\n  reset() {\n    this.board = hordeBoard();\n    this.pockets = undefined;\n    this.turn = 'white';\n    this.castles = Castles.default();\n    this.castles.discardColor('white');\n    this.epSquare = undefined;\n    this.remainingChecks = undefined;\n    this.halfmoves = 0;\n    this.fullmoves = 1;\n  }\n\n  static default(): Horde {\n    const pos = new this();\n    pos.reset();\n    return pos;\n  }\n\n  static fromSetup(setup: Setup): Result<Horde, PositionError> {\n    const pos = new this();\n    pos.setupUnchecked(setup);\n    return pos.validate().map(_ => pos);\n  }\n\n  clone(): Horde {\n    return super.clone() as Horde;\n  }\n\n  protected validate(): Result<undefined, PositionError> {\n    if (this.board.occupied.isEmpty()) return Result.err(new PositionError(IllegalSetup.Empty));\n    if (this.board.king.size() !== 1) return Result.err(new PositionError(IllegalSetup.Kings));\n\n    const otherKing = this.board.kingOf(opposite(this.turn));\n    if (defined(otherKing) && this.kingAttackers(otherKing, this.turn, this.board.occupied).nonEmpty()) {\n      return Result.err(new PositionError(IllegalSetup.OppositeCheck));\n    }\n    for (const color of COLORS) {\n      const backranks = this.board.pieces(color, 'king').isEmpty()\n        ? SquareSet.backrank(opposite(color))\n        : SquareSet.backranks();\n      if (this.board.pieces(color, 'pawn').intersects(backranks)) {\n        return Result.err(new PositionError(IllegalSetup.PawnsOnBackrank));\n      }\n    }\n    return Result.ok(undefined);\n  }\n\n  hasInsufficientMaterial(color: Color): boolean {\n    // The side with the king can always win by capturing the horde.\n    if (this.board.pieces(color, 'king').nonEmpty()) return false;\n\n    type SquareColor = 'light' | 'dark';\n    const oppositeSquareColor = (squareColor: SquareColor): SquareColor => (squareColor === 'light' ? 'dark' : 'light');\n    const coloredSquares = (squareColor: SquareColor): SquareSet =>\n      squareColor === 'light' ? SquareSet.lightSquares() : SquareSet.darkSquares();\n\n    const hasBishopPair = (side: Color) => {\n      const bishops = this.board.pieces(side, 'bishop');\n      return bishops.intersects(SquareSet.darkSquares()) && bishops.intersects(SquareSet.lightSquares());\n    };\n\n    // By this point: color is the horde.\n    // Based on\n    // https://github.com/stevepapazis/horde-insufficient-material-tests.\n    const horde = MaterialSide.fromBoard(this.board, color);\n    const hordeBishops = (squareColor: SquareColor) =>\n      coloredSquares(squareColor).intersect(this.board.pieces(color, 'bishop')).size();\n    const hordeBishopColor: SquareColor = hordeBishops('light') >= 1 ? 'light' : 'dark';\n    const hordeNum = horde.pawn\n      + horde.knight\n      + horde.rook\n      + horde.queen\n      + Math.min(hordeBishops('dark'), 2)\n      + Math.min(hordeBishops('light'), 2);\n\n    const pieces = MaterialSide.fromBoard(this.board, opposite(color));\n    const piecesBishops = (squareColor: SquareColor) =>\n      coloredSquares(squareColor)\n        .intersect(this.board.pieces(opposite(color), 'bishop'))\n        .size();\n    const piecesNum = pieces.size();\n    const piecesOfRoleNot = (piece: number) => piecesNum - piece;\n\n    if (hordeNum === 0) return true;\n    if (hordeNum >= 4) {\n      // Four or more pieces can always deliver mate.\n      return false;\n    }\n    if ((horde.pawn >= 1 || horde.queen >= 1) && hordeNum >= 2) {\n      // Pawns/queens are never insufficient material when paired with any other\n      // piece (a pawn promotes to a queen and delivers mate).\n      return false;\n    }\n    if (horde.rook >= 1 && hordeNum >= 2) {\n      // A rook is insufficient material only when it is paired with a bishop\n      // against a lone king. The horde can mate in any other case.\n      // A rook on A1 and a bishop on C3 mate a king on B1 when there is a\n      // friendly pawn/opposite-color-bishop/rook/queen on C2.\n      // A rook on B8 and a bishop C3 mate a king on A1 when there is a friendly\n      // knight on A2.\n      if (\n        !(\n          hordeNum === 2\n          && horde.rook === 1\n          && horde.bishop === 1\n          && piecesOfRoleNot(piecesBishops(hordeBishopColor)) === 1\n        )\n      ) {\n        return false;\n      }\n    }\n\n    if (hordeNum === 1) {\n      if (piecesNum === 1) {\n        // A lone piece cannot mate a lone king.\n        return true;\n      } else if (horde.queen === 1) {\n        // The horde has a lone queen.\n        // A lone queen mates a king on A1 bounded by:\n        //  -- a pawn/rook on A2\n        //  -- two same color bishops on A2, B1\n        // We ignore every other mating case, since it can be reduced to\n        // the two previous cases (e.g. a black pawn on A2 and a black\n        // bishop on B1).\n        return !(pieces.pawn >= 1 || pieces.rook >= 1 || piecesBishops('light') >= 2 || piecesBishops('dark') >= 2);\n      } else if (horde.pawn === 1) {\n        // Promote the pawn to a queen or a knight and check whether white\n        // can mate.\n        const pawnSquare = this.board.pieces(color, 'pawn').last()!;\n        const promoteToQueen = this.clone();\n        promoteToQueen.board.set(pawnSquare, { color, role: 'queen' });\n        const promoteToKnight = this.clone();\n        promoteToKnight.board.set(pawnSquare, { color, role: 'knight' });\n        return promoteToQueen.hasInsufficientMaterial(color) && promoteToKnight.hasInsufficientMaterial(color);\n      } else if (horde.rook === 1) {\n        // A lone rook mates a king on A8 bounded by a pawn/rook on A7 and a\n        // pawn/knight on B7. We ignore every other case, since it can be\n        // reduced to the two previous cases.\n        // (e.g. three pawns on A7, B7, C7)\n        return !(\n          pieces.pawn >= 2\n          || (pieces.rook >= 1 && pieces.pawn >= 1)\n          || (pieces.rook >= 1 && pieces.knight >= 1)\n          || (pieces.pawn >= 1 && pieces.knight >= 1)\n        );\n      } else if (horde.bishop === 1) {\n        // The horde has a lone bishop.\n        return !(\n          // The king can be mated on A1 if there is a pawn/opposite-color-bishop\n          // on A2 and an opposite-color-bishop on B1.\n          // If black has two or more pawns, white gets the benefit of the doubt;\n          // there is an outside chance that white promotes its pawns to\n          // opposite-color-bishops and selfmates theirself.\n          // Every other case that the king is mated by the bishop requires that\n          // black has two pawns or two opposite-color-bishop or a pawn and an\n          // opposite-color-bishop.\n          // For example a king on A3 can be mated if there is\n          // a pawn/opposite-color-bishop on A4, a pawn/opposite-color-bishop on\n          // B3, a pawn/bishop/rook/queen on A2 and any other piece on B2.\n          piecesBishops(oppositeSquareColor(hordeBishopColor)) >= 2\n          || (piecesBishops(oppositeSquareColor(hordeBishopColor)) >= 1 && pieces.pawn >= 1)\n          || pieces.pawn >= 2\n        );\n      } else if (horde.knight === 1) {\n        // The horde has a lone knight.\n        return !(\n          // The king on A1 can be smother mated by a knight on C2 if there is\n          // a pawn/knight/bishop on B2, a knight/rook on B1 and any other piece\n          // on A2.\n          // Moreover, when black has four or more pieces and two of them are\n          // pawns, black can promote their pawns and selfmate theirself.\n          piecesNum >= 4\n          && (pieces.knight >= 2\n            || pieces.pawn >= 2\n            || (pieces.rook >= 1 && pieces.knight >= 1)\n            || (pieces.rook >= 1 && pieces.bishop >= 1)\n            || (pieces.knight >= 1 && pieces.bishop >= 1)\n            || (pieces.rook >= 1 && pieces.pawn >= 1)\n            || (pieces.knight >= 1 && pieces.pawn >= 1)\n            || (pieces.bishop >= 1 && pieces.pawn >= 1)\n            || (hasBishopPair(opposite(color)) && pieces.pawn >= 1))\n          && (piecesBishops('dark') < 2 || piecesOfRoleNot(piecesBishops('dark')) >= 3)\n          && (piecesBishops('light') < 2 || piecesOfRoleNot(piecesBishops('light')) >= 3)\n        );\n      }\n\n      // By this point, we only need to deal with white's minor pieces.\n    } else if (hordeNum === 2) {\n      if (piecesNum === 1) {\n        // Two minor pieces cannot mate a lone king.\n        return true;\n      } else if (horde.knight === 2) {\n        // A king on A1 is mated by two knights, if it is obstructed by a\n        // pawn/bishop/knight on B2. On the other hand, if black only has\n        // major pieces it is a draw.\n        return pieces.pawn + pieces.bishop + pieces.knight < 1;\n      } else if (hasBishopPair(color)) {\n        return !(\n          // A king on A1 obstructed by a pawn/bishop on A2 is mated\n          // by the bishop pair.\n          pieces.pawn >= 1\n          || pieces.bishop >= 1\n          // A pawn/bishop/knight on B4, a pawn/bishop/rook/queen on\n          // A4 and the king on A3 enable Boden's mate by the bishop\n          // pair. In every other case white cannot win.\n          || (pieces.knight >= 1 && pieces.rook + pieces.queen >= 1)\n        );\n      } else if (horde.bishop >= 1 && horde.knight >= 1) {\n        // The horde has a bishop and a knight.\n        return !(\n          // A king on A1 obstructed by a pawn/opposite-color-bishop on\n          // A2 is mated by a knight on D2 and a bishop on C3.\n          pieces.pawn >= 1\n          || piecesBishops(oppositeSquareColor(hordeBishopColor)) >= 1\n          // A king on A1 bounded by two friendly pieces on A2 and B1 is\n          // mated when the knight moves from D4 to C2 so that both the\n          // knight and the bishop deliver check.\n          || piecesOfRoleNot(piecesBishops(hordeBishopColor)) >= 3\n        );\n      } else {\n        // The horde has two or more bishops on the same color.\n        // White can only win if black has enough material to obstruct\n        // the squares of the opposite color around the king.\n        return !(\n          // A king on A1 obstructed by a pawn/opposite-bishop/knight\n          // on A2 and a opposite-bishop/knight on B1 is mated by two\n          // bishops on B2 and C3. This position is theoretically\n          // achievable even when black has two pawns or when they\n          // have a pawn and an opposite color bishop.\n          (pieces.pawn >= 1 && piecesBishops(oppositeSquareColor(hordeBishopColor)) >= 1)\n          || (pieces.pawn >= 1 && pieces.knight >= 1)\n          || (piecesBishops(oppositeSquareColor(hordeBishopColor)) >= 1 && pieces.knight >= 1)\n          || piecesBishops(oppositeSquareColor(hordeBishopColor)) >= 2\n          || pieces.knight >= 2\n          || pieces.pawn >= 2\n          // In every other case, white can only draw.\n        );\n      }\n    } else if (hordeNum === 3) {\n      // A king in the corner is mated by two knights and a bishop or three\n      // knights or the bishop pair and a knight/bishop.\n      if ((horde.knight === 2 && horde.bishop === 1) || horde.knight === 3 || hasBishopPair(color)) {\n        return false;\n      } else {\n        // White has two same color bishops and a knight.\n        // A king on A1 is mated by a bishop on B2, a bishop on C1 and a\n        // knight on C3, as long as there is another black piece to waste\n        // a tempo.\n        return piecesNum === 1;\n      }\n    }\n\n    return true;\n  }\n\n  isVariantEnd(): boolean {\n    return this.board.white.isEmpty() || this.board.black.isEmpty();\n  }\n\n  variantOutcome(_ctx?: Context): Outcome | undefined {\n    if (this.board.white.isEmpty()) return { winner: 'black' };\n    if (this.board.black.isEmpty()) return { winner: 'white' };\n    return;\n  }\n}\n\nexport const defaultPosition = (rules: Rules): Position => {\n  switch (rules) {\n    case 'chess':\n      return Chess.default();\n    case 'antichess':\n      return Antichess.default();\n    case 'atomic':\n      return Atomic.default();\n    case 'horde':\n      return Horde.default();\n    case 'racingkings':\n      return RacingKings.default();\n    case 'kingofthehill':\n      return KingOfTheHill.default();\n    case '3check':\n      return ThreeCheck.default();\n    case 'crazyhouse':\n      return Crazyhouse.default();\n  }\n};\n\nexport const setupPosition = (rules: Rules, setup: Setup): Result<Position, PositionError> => {\n  switch (rules) {\n    case 'chess':\n      return Chess.fromSetup(setup);\n    case 'antichess':\n      return Antichess.fromSetup(setup);\n    case 'atomic':\n      return Atomic.fromSetup(setup);\n    case 'horde':\n      return Horde.fromSetup(setup);\n    case 'racingkings':\n      return RacingKings.fromSetup(setup);\n    case 'kingofthehill':\n      return KingOfTheHill.fromSetup(setup);\n    case '3check':\n      return ThreeCheck.fromSetup(setup);\n    case 'crazyhouse':\n      return Crazyhouse.fromSetup(setup);\n  }\n};\n\nexport const isStandardMaterial = (pos: Position): boolean => {\n  switch (pos.rules) {\n    case 'chess':\n    case 'antichess':\n    case 'atomic':\n    case 'kingofthehill':\n    case '3check':\n      return COLORS.every(color => isStandardMaterialSide(pos.board, color));\n    case 'crazyhouse': {\n      const promoted = pos.board.promoted;\n      return (\n        promoted.size() + pos.board.pawn.size() + (pos.pockets?.count('pawn') || 0) <= 16\n        && pos.board.knight.diff(promoted).size() + (pos.pockets?.count('knight') || 0) <= 4\n        && pos.board.bishop.diff(promoted).size() + (pos.pockets?.count('bishop') || 0) <= 4\n        && pos.board.rook.diff(promoted).size() + (pos.pockets?.count('rook') || 0) <= 4\n        && pos.board.queen.diff(promoted).size() + (pos.pockets?.count('queen') || 0) <= 2\n      );\n    }\n    case 'horde':\n      return COLORS.every(color =>\n        pos.board.pieces(color, 'king').nonEmpty()\n          ? isStandardMaterialSide(pos.board, color)\n          : pos.board[color].size() <= 36\n      );\n    case 'racingkings':\n      return COLORS.every(\n        color =>\n          pos.board.pieces(color, 'knight').size() <= 2\n          && pos.board.pieces(color, 'bishop').size() <= 2\n          && pos.board.pieces(color, 'rook').size() <= 2\n          && pos.board.pieces(color, 'queen').size() <= 1,\n      );\n  }\n};\n"],
  "mappings": "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",
  "names": ["ctx", "variations", "firstVariation"]
}
