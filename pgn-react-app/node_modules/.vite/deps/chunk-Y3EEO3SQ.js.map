{
  "version": 3,
  "sources": ["../../../../node_modules/chessops/src/chess.ts"],
  "sourcesContent": ["import { Result } from '@badrap/result';\nimport {\n  attacks,\n  between,\n  bishopAttacks,\n  kingAttacks,\n  knightAttacks,\n  pawnAttacks,\n  queenAttacks,\n  ray,\n  rookAttacks,\n} from './attacks.js';\nimport { Board, boardEquals } from './board.js';\nimport { Material, RemainingChecks, Setup } from './setup.js';\nimport { SquareSet } from './squareSet.js';\nimport {\n  ByCastlingSide,\n  ByColor,\n  CASTLING_SIDES,\n  CastlingSide,\n  Color,\n  COLORS,\n  isDrop,\n  Move,\n  NormalMove,\n  Outcome,\n  Piece,\n  Rules,\n  Square,\n} from './types.js';\nimport { defined, kingCastlesTo, opposite, rookCastlesTo, squareRank } from './util.js';\n\nexport enum IllegalSetup {\n  Empty = 'ERR_EMPTY',\n  OppositeCheck = 'ERR_OPPOSITE_CHECK',\n  PawnsOnBackrank = 'ERR_PAWNS_ON_BACKRANK',\n  Kings = 'ERR_KINGS',\n  Variant = 'ERR_VARIANT',\n}\n\nexport class PositionError extends Error {}\n\nconst attacksTo = (square: Square, attacker: Color, board: Board, occupied: SquareSet): SquareSet =>\n  board[attacker].intersect(\n    rookAttacks(square, occupied)\n      .intersect(board.rooksAndQueens())\n      .union(bishopAttacks(square, occupied).intersect(board.bishopsAndQueens()))\n      .union(knightAttacks(square).intersect(board.knight))\n      .union(kingAttacks(square).intersect(board.king))\n      .union(pawnAttacks(opposite(attacker), square).intersect(board.pawn)),\n  );\n\nexport class Castles {\n  castlingRights: SquareSet;\n  rook: ByColor<ByCastlingSide<Square | undefined>>;\n  path: ByColor<ByCastlingSide<SquareSet>>;\n\n  private constructor() {}\n\n  static default(): Castles {\n    const castles = new Castles();\n    castles.castlingRights = SquareSet.corners();\n    castles.rook = {\n      white: { a: 0, h: 7 },\n      black: { a: 56, h: 63 },\n    };\n    castles.path = {\n      white: { a: new SquareSet(0xe, 0), h: new SquareSet(0x60, 0) },\n      black: { a: new SquareSet(0, 0x0e000000), h: new SquareSet(0, 0x60000000) },\n    };\n    return castles;\n  }\n\n  static empty(): Castles {\n    const castles = new Castles();\n    castles.castlingRights = SquareSet.empty();\n    castles.rook = {\n      white: { a: undefined, h: undefined },\n      black: { a: undefined, h: undefined },\n    };\n    castles.path = {\n      white: { a: SquareSet.empty(), h: SquareSet.empty() },\n      black: { a: SquareSet.empty(), h: SquareSet.empty() },\n    };\n    return castles;\n  }\n\n  clone(): Castles {\n    const castles = new Castles();\n    castles.castlingRights = this.castlingRights;\n    castles.rook = {\n      white: { a: this.rook.white.a, h: this.rook.white.h },\n      black: { a: this.rook.black.a, h: this.rook.black.h },\n    };\n    castles.path = {\n      white: { a: this.path.white.a, h: this.path.white.h },\n      black: { a: this.path.black.a, h: this.path.black.h },\n    };\n    return castles;\n  }\n\n  private add(color: Color, side: CastlingSide, king: Square, rook: Square): void {\n    const kingTo = kingCastlesTo(color, side);\n    const rookTo = rookCastlesTo(color, side);\n    this.castlingRights = this.castlingRights.with(rook);\n    this.rook[color][side] = rook;\n    this.path[color][side] = between(rook, rookTo)\n      .with(rookTo)\n      .union(between(king, kingTo).with(kingTo))\n      .without(king)\n      .without(rook);\n  }\n\n  static fromSetup(setup: Setup): Castles {\n    const castles = Castles.empty();\n    const rooks = setup.castlingRights.intersect(setup.board.rook);\n    for (const color of COLORS) {\n      const backrank = SquareSet.backrank(color);\n      const king = setup.board.kingOf(color);\n      if (!defined(king) || !backrank.has(king)) continue;\n      const side = rooks.intersect(setup.board[color]).intersect(backrank);\n      const aSide = side.first();\n      if (defined(aSide) && aSide < king) castles.add(color, 'a', king, aSide);\n      const hSide = side.last();\n      if (defined(hSide) && king < hSide) castles.add(color, 'h', king, hSide);\n    }\n    return castles;\n  }\n\n  discardRook(square: Square): void {\n    if (this.castlingRights.has(square)) {\n      this.castlingRights = this.castlingRights.without(square);\n      for (const color of COLORS) {\n        for (const side of CASTLING_SIDES) {\n          if (this.rook[color][side] === square) this.rook[color][side] = undefined;\n        }\n      }\n    }\n  }\n\n  discardColor(color: Color): void {\n    this.castlingRights = this.castlingRights.diff(SquareSet.backrank(color));\n    this.rook[color].a = undefined;\n    this.rook[color].h = undefined;\n  }\n}\n\nexport interface Context {\n  king: Square | undefined;\n  blockers: SquareSet;\n  checkers: SquareSet;\n  variantEnd: boolean;\n  mustCapture: boolean;\n}\n\nexport abstract class Position {\n  board: Board;\n  pockets: Material | undefined;\n  turn: Color;\n  castles: Castles;\n  epSquare: Square | undefined;\n  remainingChecks: RemainingChecks | undefined;\n  halfmoves: number;\n  fullmoves: number;\n\n  protected constructor(readonly rules: Rules) {}\n\n  reset() {\n    this.board = Board.default();\n    this.pockets = undefined;\n    this.turn = 'white';\n    this.castles = Castles.default();\n    this.epSquare = undefined;\n    this.remainingChecks = undefined;\n    this.halfmoves = 0;\n    this.fullmoves = 1;\n  }\n\n  protected setupUnchecked(setup: Setup) {\n    this.board = setup.board.clone();\n    this.board.promoted = SquareSet.empty();\n    this.pockets = undefined;\n    this.turn = setup.turn;\n    this.castles = Castles.fromSetup(setup);\n    this.epSquare = validEpSquare(this, setup.epSquare);\n    this.remainingChecks = undefined;\n    this.halfmoves = setup.halfmoves;\n    this.fullmoves = setup.fullmoves;\n  }\n\n  // When subclassing overwrite at least:\n  //\n  // - static default()\n  // - static fromSetup()\n  // - static clone()\n  //\n  // - dests()\n  // - isVariantEnd()\n  // - variantOutcome()\n  // - hasInsufficientMaterial()\n  // - isStandardMaterial()\n\n  kingAttackers(square: Square, attacker: Color, occupied: SquareSet): SquareSet {\n    return attacksTo(square, attacker, this.board, occupied);\n  }\n\n  protected playCaptureAt(square: Square, captured: Piece): void {\n    this.halfmoves = 0;\n    if (captured.role === 'rook') this.castles.discardRook(square);\n    if (this.pockets) this.pockets[opposite(captured.color)][captured.promoted ? 'pawn' : captured.role]++;\n  }\n\n  ctx(): Context {\n    const variantEnd = this.isVariantEnd();\n    const king = this.board.kingOf(this.turn);\n    if (!defined(king)) {\n      return { king, blockers: SquareSet.empty(), checkers: SquareSet.empty(), variantEnd, mustCapture: false };\n    }\n    const snipers = rookAttacks(king, SquareSet.empty())\n      .intersect(this.board.rooksAndQueens())\n      .union(bishopAttacks(king, SquareSet.empty()).intersect(this.board.bishopsAndQueens()))\n      .intersect(this.board[opposite(this.turn)]);\n    let blockers = SquareSet.empty();\n    for (const sniper of snipers) {\n      const b = between(king, sniper).intersect(this.board.occupied);\n      if (!b.moreThanOne()) blockers = blockers.union(b);\n    }\n    const checkers = this.kingAttackers(king, opposite(this.turn), this.board.occupied);\n    return {\n      king,\n      blockers,\n      checkers,\n      variantEnd,\n      mustCapture: false,\n    };\n  }\n\n  clone(): Position {\n    const pos = new (this as any).constructor();\n    pos.board = this.board.clone();\n    pos.pockets = this.pockets?.clone();\n    pos.turn = this.turn;\n    pos.castles = this.castles.clone();\n    pos.epSquare = this.epSquare;\n    pos.remainingChecks = this.remainingChecks?.clone();\n    pos.halfmoves = this.halfmoves;\n    pos.fullmoves = this.fullmoves;\n    return pos;\n  }\n\n  protected validate(): Result<undefined, PositionError> {\n    if (this.board.occupied.isEmpty()) return Result.err(new PositionError(IllegalSetup.Empty));\n    if (this.board.king.size() !== 2) return Result.err(new PositionError(IllegalSetup.Kings));\n\n    if (!defined(this.board.kingOf(this.turn))) return Result.err(new PositionError(IllegalSetup.Kings));\n\n    const otherKing = this.board.kingOf(opposite(this.turn));\n    if (!defined(otherKing)) return Result.err(new PositionError(IllegalSetup.Kings));\n    if (this.kingAttackers(otherKing, this.turn, this.board.occupied).nonEmpty()) {\n      return Result.err(new PositionError(IllegalSetup.OppositeCheck));\n    }\n\n    if (SquareSet.backranks().intersects(this.board.pawn)) {\n      return Result.err(new PositionError(IllegalSetup.PawnsOnBackrank));\n    }\n\n    return Result.ok(undefined);\n  }\n\n  dropDests(_ctx?: Context): SquareSet {\n    return SquareSet.empty();\n  }\n\n  dests(square: Square, ctx?: Context): SquareSet {\n    ctx = ctx || this.ctx();\n    if (ctx.variantEnd) return SquareSet.empty();\n    const piece = this.board.get(square);\n    if (!piece || piece.color !== this.turn) return SquareSet.empty();\n\n    let pseudo, legal;\n    if (piece.role === 'pawn') {\n      pseudo = pawnAttacks(this.turn, square).intersect(this.board[opposite(this.turn)]);\n      const delta = this.turn === 'white' ? 8 : -8;\n      const step = square + delta;\n      if (0 <= step && step < 64 && !this.board.occupied.has(step)) {\n        pseudo = pseudo.with(step);\n        const canDoubleStep = this.turn === 'white' ? square < 16 : square >= 64 - 16;\n        const doubleStep = step + delta;\n        if (canDoubleStep && !this.board.occupied.has(doubleStep)) {\n          pseudo = pseudo.with(doubleStep);\n        }\n      }\n      if (defined(this.epSquare) && canCaptureEp(this, square, ctx)) {\n        legal = SquareSet.fromSquare(this.epSquare);\n      }\n    } else if (piece.role === 'bishop') pseudo = bishopAttacks(square, this.board.occupied);\n    else if (piece.role === 'knight') pseudo = knightAttacks(square);\n    else if (piece.role === 'rook') pseudo = rookAttacks(square, this.board.occupied);\n    else if (piece.role === 'queen') pseudo = queenAttacks(square, this.board.occupied);\n    else pseudo = kingAttacks(square);\n\n    pseudo = pseudo.diff(this.board[this.turn]);\n\n    if (defined(ctx.king)) {\n      if (piece.role === 'king') {\n        const occ = this.board.occupied.without(square);\n        for (const to of pseudo) {\n          if (this.kingAttackers(to, opposite(this.turn), occ).nonEmpty()) pseudo = pseudo.without(to);\n        }\n        return pseudo.union(castlingDest(this, 'a', ctx)).union(castlingDest(this, 'h', ctx));\n      }\n\n      if (ctx.checkers.nonEmpty()) {\n        const checker = ctx.checkers.singleSquare();\n        if (!defined(checker)) return SquareSet.empty();\n        pseudo = pseudo.intersect(between(checker, ctx.king).with(checker));\n      }\n\n      if (ctx.blockers.has(square)) pseudo = pseudo.intersect(ray(square, ctx.king));\n    }\n\n    if (legal) pseudo = pseudo.union(legal);\n    return pseudo;\n  }\n\n  isVariantEnd(): boolean {\n    return false;\n  }\n\n  variantOutcome(_ctx?: Context): Outcome | undefined {\n    return;\n  }\n\n  hasInsufficientMaterial(color: Color): boolean {\n    if (this.board[color].intersect(this.board.pawn.union(this.board.rooksAndQueens())).nonEmpty()) return false;\n    if (this.board[color].intersects(this.board.knight)) {\n      return (\n        this.board[color].size() <= 2\n        && this.board[opposite(color)].diff(this.board.king).diff(this.board.queen).isEmpty()\n      );\n    }\n    if (this.board[color].intersects(this.board.bishop)) {\n      const sameColor = !this.board.bishop.intersects(SquareSet.darkSquares())\n        || !this.board.bishop.intersects(SquareSet.lightSquares());\n      return sameColor && this.board.pawn.isEmpty() && this.board.knight.isEmpty();\n    }\n    return true;\n  }\n\n  // The following should be identical in all subclasses\n\n  toSetup(): Setup {\n    return {\n      board: this.board.clone(),\n      pockets: this.pockets?.clone(),\n      turn: this.turn,\n      castlingRights: this.castles.castlingRights,\n      epSquare: legalEpSquare(this),\n      remainingChecks: this.remainingChecks?.clone(),\n      halfmoves: Math.min(this.halfmoves, 150),\n      fullmoves: Math.min(Math.max(this.fullmoves, 1), 9999),\n    };\n  }\n\n  isInsufficientMaterial(): boolean {\n    return COLORS.every(color => this.hasInsufficientMaterial(color));\n  }\n\n  hasDests(ctx?: Context): boolean {\n    ctx = ctx || this.ctx();\n    for (const square of this.board[this.turn]) {\n      if (this.dests(square, ctx).nonEmpty()) return true;\n    }\n    return this.dropDests(ctx).nonEmpty();\n  }\n\n  isLegal(move: Move, ctx?: Context): boolean {\n    if (isDrop(move)) {\n      if (!this.pockets || this.pockets[this.turn][move.role] <= 0) return false;\n      if (move.role === 'pawn' && SquareSet.backranks().has(move.to)) return false;\n      return this.dropDests(ctx).has(move.to);\n    } else {\n      if (move.promotion === 'pawn') return false;\n      if (move.promotion === 'king' && this.rules !== 'antichess') return false;\n      if (!!move.promotion !== (this.board.pawn.has(move.from) && SquareSet.backranks().has(move.to))) return false;\n      const dests = this.dests(move.from, ctx);\n      return dests.has(move.to) || dests.has(normalizeMove(this, move).to);\n    }\n  }\n\n  isCheck(): boolean {\n    const king = this.board.kingOf(this.turn);\n    return defined(king) && this.kingAttackers(king, opposite(this.turn), this.board.occupied).nonEmpty();\n  }\n\n  isEnd(ctx?: Context): boolean {\n    if (ctx ? ctx.variantEnd : this.isVariantEnd()) return true;\n    return this.isInsufficientMaterial() || !this.hasDests(ctx);\n  }\n\n  isCheckmate(ctx?: Context): boolean {\n    ctx = ctx || this.ctx();\n    return !ctx.variantEnd && ctx.checkers.nonEmpty() && !this.hasDests(ctx);\n  }\n\n  isStalemate(ctx?: Context): boolean {\n    ctx = ctx || this.ctx();\n    return !ctx.variantEnd && ctx.checkers.isEmpty() && !this.hasDests(ctx);\n  }\n\n  outcome(ctx?: Context): Outcome | undefined {\n    const variantOutcome = this.variantOutcome(ctx);\n    if (variantOutcome) return variantOutcome;\n    ctx = ctx || this.ctx();\n    if (this.isCheckmate(ctx)) return { winner: opposite(this.turn) };\n    else if (this.isInsufficientMaterial() || this.isStalemate(ctx)) return { winner: undefined };\n    else return;\n  }\n\n  allDests(ctx?: Context): Map<Square, SquareSet> {\n    ctx = ctx || this.ctx();\n    const d = new Map();\n    if (ctx.variantEnd) return d;\n    for (const square of this.board[this.turn]) {\n      d.set(square, this.dests(square, ctx));\n    }\n    return d;\n  }\n\n  play(move: Move): void {\n    const turn = this.turn;\n    const epSquare = this.epSquare;\n    const castling = castlingSide(this, move);\n\n    this.epSquare = undefined;\n    this.halfmoves += 1;\n    if (turn === 'black') this.fullmoves += 1;\n    this.turn = opposite(turn);\n\n    if (isDrop(move)) {\n      this.board.set(move.to, { role: move.role, color: turn });\n      if (this.pockets) this.pockets[turn][move.role]--;\n      if (move.role === 'pawn') this.halfmoves = 0;\n    } else {\n      const piece = this.board.take(move.from);\n      if (!piece) return;\n\n      let epCapture: Piece | undefined;\n      if (piece.role === 'pawn') {\n        this.halfmoves = 0;\n        if (move.to === epSquare) {\n          epCapture = this.board.take(move.to + (turn === 'white' ? -8 : 8));\n        }\n        const delta = move.from - move.to;\n        if (Math.abs(delta) === 16 && 8 <= move.from && move.from <= 55) {\n          this.epSquare = (move.from + move.to) >> 1;\n        }\n        if (move.promotion) {\n          piece.role = move.promotion;\n          piece.promoted = !!this.pockets;\n        }\n      } else if (piece.role === 'rook') {\n        this.castles.discardRook(move.from);\n      } else if (piece.role === 'king') {\n        if (castling) {\n          const rookFrom = this.castles.rook[turn][castling];\n          if (defined(rookFrom)) {\n            const rook = this.board.take(rookFrom);\n            this.board.set(kingCastlesTo(turn, castling), piece);\n            if (rook) this.board.set(rookCastlesTo(turn, castling), rook);\n          }\n        }\n        this.castles.discardColor(turn);\n      }\n\n      if (!castling) {\n        const capture = this.board.set(move.to, piece) || epCapture;\n        if (capture) this.playCaptureAt(move.to, capture);\n      }\n    }\n\n    if (this.remainingChecks) {\n      if (this.isCheck()) this.remainingChecks[turn] = Math.max(this.remainingChecks[turn] - 1, 0);\n    }\n  }\n}\n\nexport class Chess extends Position {\n  private constructor() {\n    super('chess');\n  }\n\n  static default(): Chess {\n    const pos = new this();\n    pos.reset();\n    return pos;\n  }\n\n  static fromSetup(setup: Setup): Result<Chess, PositionError> {\n    const pos = new this();\n    pos.setupUnchecked(setup);\n    return pos.validate().map(_ => pos);\n  }\n\n  clone(): Chess {\n    return super.clone() as Chess;\n  }\n}\n\nconst validEpSquare = (pos: Position, square: Square | undefined): Square | undefined => {\n  if (!defined(square)) return;\n  const epRank = pos.turn === 'white' ? 5 : 2;\n  const forward = pos.turn === 'white' ? 8 : -8;\n  if (squareRank(square) !== epRank) return;\n  if (pos.board.occupied.has(square + forward)) return;\n  const pawn = square - forward;\n  if (!pos.board.pawn.has(pawn) || !pos.board[opposite(pos.turn)].has(pawn)) return;\n  return square;\n};\n\nconst legalEpSquare = (pos: Position): Square | undefined => {\n  if (!defined(pos.epSquare)) return;\n  const ctx = pos.ctx();\n  const ourPawns = pos.board.pieces(pos.turn, 'pawn');\n  const candidates = ourPawns.intersect(pawnAttacks(opposite(pos.turn), pos.epSquare));\n  for (const candidate of candidates) {\n    if (pos.dests(candidate, ctx).has(pos.epSquare)) return pos.epSquare;\n  }\n  return;\n};\n\nconst canCaptureEp = (pos: Position, pawnFrom: Square, ctx: Context): boolean => {\n  if (!defined(pos.epSquare)) return false;\n  if (!pawnAttacks(pos.turn, pawnFrom).has(pos.epSquare)) return false;\n  if (!defined(ctx.king)) return true;\n  const delta = pos.turn === 'white' ? 8 : -8;\n  const captured = pos.epSquare - delta;\n  return pos\n    .kingAttackers(\n      ctx.king,\n      opposite(pos.turn),\n      pos.board.occupied.toggle(pawnFrom).toggle(captured).with(pos.epSquare),\n    )\n    .without(captured)\n    .isEmpty();\n};\n\nconst castlingDest = (pos: Position, side: CastlingSide, ctx: Context): SquareSet => {\n  if (!defined(ctx.king) || ctx.checkers.nonEmpty()) return SquareSet.empty();\n  const rook = pos.castles.rook[pos.turn][side];\n  if (!defined(rook)) return SquareSet.empty();\n  if (pos.castles.path[pos.turn][side].intersects(pos.board.occupied)) return SquareSet.empty();\n\n  const kingTo = kingCastlesTo(pos.turn, side);\n  const kingPath = between(ctx.king, kingTo);\n  const occ = pos.board.occupied.without(ctx.king);\n  for (const sq of kingPath) {\n    if (pos.kingAttackers(sq, opposite(pos.turn), occ).nonEmpty()) return SquareSet.empty();\n  }\n\n  const rookTo = rookCastlesTo(pos.turn, side);\n  const after = pos.board.occupied.toggle(ctx.king).toggle(rook).toggle(rookTo);\n  if (pos.kingAttackers(kingTo, opposite(pos.turn), after).nonEmpty()) return SquareSet.empty();\n\n  return SquareSet.fromSquare(rook);\n};\n\nexport const pseudoDests = (pos: Position, square: Square, ctx: Context): SquareSet => {\n  if (ctx.variantEnd) return SquareSet.empty();\n  const piece = pos.board.get(square);\n  if (!piece || piece.color !== pos.turn) return SquareSet.empty();\n\n  let pseudo = attacks(piece, square, pos.board.occupied);\n  if (piece.role === 'pawn') {\n    let captureTargets = pos.board[opposite(pos.turn)];\n    if (defined(pos.epSquare)) captureTargets = captureTargets.with(pos.epSquare);\n    pseudo = pseudo.intersect(captureTargets);\n    const delta = pos.turn === 'white' ? 8 : -8;\n    const step = square + delta;\n    if (0 <= step && step < 64 && !pos.board.occupied.has(step)) {\n      pseudo = pseudo.with(step);\n      const canDoubleStep = pos.turn === 'white' ? square < 16 : square >= 64 - 16;\n      const doubleStep = step + delta;\n      if (canDoubleStep && !pos.board.occupied.has(doubleStep)) {\n        pseudo = pseudo.with(doubleStep);\n      }\n    }\n    return pseudo;\n  } else {\n    pseudo = pseudo.diff(pos.board[pos.turn]);\n  }\n  if (square === ctx.king) return pseudo.union(castlingDest(pos, 'a', ctx)).union(castlingDest(pos, 'h', ctx));\n  else return pseudo;\n};\n\nexport const equalsIgnoreMoves = (left: Position, right: Position): boolean =>\n  left.rules === right.rules\n  && boardEquals(left.board, right.board)\n  && ((right.pockets && left.pockets?.equals(right.pockets)) || (!left.pockets && !right.pockets))\n  && left.turn === right.turn\n  && left.castles.castlingRights.equals(right.castles.castlingRights)\n  && legalEpSquare(left) === legalEpSquare(right)\n  && ((right.remainingChecks && left.remainingChecks?.equals(right.remainingChecks))\n    || (!left.remainingChecks && !right.remainingChecks));\n\nexport const castlingSide = (pos: Position, move: Move): CastlingSide | undefined => {\n  if (isDrop(move)) return;\n  const delta = move.to - move.from;\n  if (Math.abs(delta) !== 2 && !pos.board[pos.turn].has(move.to)) return;\n  if (!pos.board.king.has(move.from)) return;\n  return delta > 0 ? 'h' : 'a';\n};\n\nexport const normalizeMove = (pos: Position, move: Move): Move => {\n  const side = castlingSide(pos, move);\n  if (!side) return move;\n  const rookFrom = pos.castles.rook[pos.turn][side];\n  return {\n    from: (move as NormalMove).from,\n    to: defined(rookFrom) ? rookFrom : move.to,\n  };\n};\n\nexport const isStandardMaterialSide = (board: Board, color: Color): boolean => {\n  const promoted = Math.max(board.pieces(color, 'queen').size() - 1, 0)\n    + Math.max(board.pieces(color, 'rook').size() - 2, 0)\n    + Math.max(board.pieces(color, 'knight').size() - 2, 0)\n    + Math.max(board.pieces(color, 'bishop').intersect(SquareSet.lightSquares()).size() - 1, 0)\n    + Math.max(board.pieces(color, 'bishop').intersect(SquareSet.darkSquares()).size() - 1, 0);\n  return board.pieces(color, 'pawn').size() + promoted <= 8;\n};\n\nexport const isStandardMaterial = (pos: Chess): boolean =>\n  COLORS.every(color => isStandardMaterialSide(pos.board, color));\n\nexport const isImpossibleCheck = (pos: Position): boolean => {\n  const ourKing = pos.board.kingOf(pos.turn);\n  if (!defined(ourKing)) return false;\n  const checkers = pos.kingAttackers(ourKing, opposite(pos.turn), pos.board.occupied);\n  if (checkers.isEmpty()) return false;\n  if (defined(pos.epSquare)) {\n    // The pushed pawn must be the only checker, or it has uncovered\n    // check by a single sliding piece.\n    const pushedTo = pos.epSquare ^ 8;\n    const pushedFrom = pos.epSquare ^ 24;\n    return (\n      checkers.moreThanOne()\n      || (checkers.first()! !== pushedTo\n        && pos\n          .kingAttackers(ourKing, opposite(pos.turn), pos.board.occupied.without(pushedTo).with(pushedFrom))\n          .nonEmpty())\n    );\n  } else if (pos.rules === 'atomic') {\n    // Other king moving away can cause many checks to be given at the same\n    // time. Not checking details, or even that the king is close enough.\n    return false;\n  } else {\n    // Sliding checkers aligned with king.\n    return checkers.size() > 2 || (checkers.size() === 2 && ray(checkers.first()!, checkers.last()!).has(ourKing));\n  }\n};\n"],
  "mappings": "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",
  "names": ["IllegalSetup"]
}
