import {
  require_jsx_runtime
} from "./chunk-JIJDWBGI.js";
import {
  require_react
} from "./chunk-QDUQBZZD.js";
import {
  __toESM
} from "./chunk-DC5AMYBS.js";

// ../node_modules/react-chessboard/dist/index.esm.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react = __toESM(require_react());
var m = (0, import_react.createContext)({ dragDropManager: void 0 });
var b = "function" == typeof Symbol && Symbol.observable || "@@observable";
var O = function() {
  return Math.random().toString(36).substring(7).split("").join(".");
};
var w = { INIT: "@@redux/INIT" + O(), REPLACE: "@@redux/REPLACE" + O(), PROBE_UNKNOWN_ACTION: function() {
  return "@@redux/PROBE_UNKNOWN_ACTION" + O();
} };
function S(e3) {
  if (void 0 === e3) return "undefined";
  if (null === e3) return "null";
  var t2 = typeof e3;
  switch (t2) {
    case "boolean":
    case "string":
    case "number":
    case "symbol":
    case "function":
      return t2;
  }
  if (Array.isArray(e3)) return "array";
  if (function(e4) {
    return e4 instanceof Date || "function" == typeof e4.toDateString && "function" == typeof e4.getDate && "function" == typeof e4.setDate;
  }(e3)) return "date";
  if (function(e4) {
    return e4 instanceof Error || "string" == typeof e4.message && e4.constructor && "number" == typeof e4.constructor.stackTraceLimit;
  }(e3)) return "error";
  var r2 = function(e4) {
    return "function" == typeof e4.constructor ? e4.constructor.name : null;
  }(e3);
  switch (r2) {
    case "Symbol":
    case "Promise":
    case "WeakMap":
    case "WeakSet":
    case "Map":
    case "Set":
      return r2;
  }
  return t2.slice(8, -1).toLowerCase().replace(/\s/g, "");
}
function D(e3) {
  var t2 = typeof e3;
  return t2 = S(e3), t2;
}
function C(e3, t2, r2) {
  var n2;
  if ("function" == typeof t2 && "function" == typeof r2 || "function" == typeof r2 && "function" == typeof arguments[3]) throw new Error(false ? y(0) : "It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.");
  if ("function" == typeof t2 && void 0 === r2 && (r2 = t2, t2 = void 0), void 0 !== r2) {
    if ("function" != typeof r2) throw new Error(false ? y(1) : "Expected the enhancer to be a function. Instead, received: '" + D(r2) + "'");
    return r2(C)(e3, t2);
  }
  if ("function" != typeof e3) throw new Error(false ? y(2) : "Expected the root reducer to be a function. Instead, received: '" + D(e3) + "'");
  var o2 = e3, i2 = t2, s2 = [], a2 = s2, c2 = false;
  function l2() {
    a2 === s2 && (a2 = s2.slice());
  }
  function u2() {
    if (c2) throw new Error(false ? y(3) : "You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
    return i2;
  }
  function d2(e4) {
    if ("function" != typeof e4) throw new Error(false ? y(4) : "Expected the listener to be a function. Instead, received: '" + D(e4) + "'");
    if (c2) throw new Error(false ? y(5) : "You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.");
    var t3 = true;
    return l2(), a2.push(e4), function() {
      if (t3) {
        if (c2) throw new Error(false ? y(6) : "You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.");
        t3 = false, l2();
        var r3 = a2.indexOf(e4);
        a2.splice(r3, 1), s2 = null;
      }
    };
  }
  function h2(e4) {
    if (!function(e5) {
      if ("object" != typeof e5 || null === e5) return false;
      for (var t4 = e5; null !== Object.getPrototypeOf(t4); ) t4 = Object.getPrototypeOf(t4);
      return Object.getPrototypeOf(e5) === t4;
    }(e4)) throw new Error(false ? y(7) : "Actions must be plain objects. Instead, the actual type was: '" + D(e4) + "'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.");
    if (void 0 === e4.type) throw new Error(false ? y(8) : 'Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
    if (c2) throw new Error(false ? y(9) : "Reducers may not dispatch actions.");
    try {
      c2 = true, i2 = o2(i2, e4);
    } finally {
      c2 = false;
    }
    for (var t3 = s2 = a2, r3 = 0; r3 < t3.length; r3++) {
      (0, t3[r3])();
    }
    return e4;
  }
  return h2({ type: w.INIT }), (n2 = { dispatch: h2, subscribe: d2, getState: u2, replaceReducer: function(e4) {
    if ("function" != typeof e4) throw new Error(false ? y(10) : "Expected the nextReducer to be a function. Instead, received: '" + D(e4));
    o2 = e4, h2({ type: w.REPLACE });
  } })[b] = function() {
    var e4, t3 = d2;
    return (e4 = { subscribe: function(e5) {
      if ("object" != typeof e5 || null === e5) throw new Error(false ? y(11) : "Expected the observer to be an object. Instead, received: '" + D(e5) + "'");
      function r3() {
        e5.next && e5.next(u2());
      }
      return r3(), { unsubscribe: t3(r3) };
    } })[b] = function() {
      return this;
    }, e4;
  }, n2;
}
function T() {
}
function E(e3, t2, ...r2) {
  if ("undefined" != typeof process && false) throw new Error("invariant requires an error message argument");
  if (!e3) {
    let e4;
    if (void 0 === t2) e4 = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
    else {
      let n2 = 0;
      e4 = new Error(t2.replace(/%s/g, function() {
        return r2[n2++];
      })), e4.name = "Invariant Violation";
    }
    throw e4.framesToPop = 1, e4;
  }
}
function I(e3) {
  return "object" == typeof e3;
}
"string" == typeof T.name && "isCrushed" !== T.name && function(e3) {
  "undefined" != typeof console && "function" == typeof console.error && console.error(e3);
  try {
    throw new Error(e3);
  } catch (e4) {
  }
}('You are currently using minified code outside of NODE_ENV === "production". This means that you are running a slower development build of Redux. You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) to ensure you have the correct code for your production build.');
var k = "dnd-core/INIT_COORDS";
var L = "dnd-core/BEGIN_DRAG";
var P = "dnd-core/PUBLISH_DRAG_SOURCE";
var x = "dnd-core/HOVER";
var M = "dnd-core/DROP";
var N = "dnd-core/END_DRAG";
function j(e3, t2) {
  return { type: k, payload: { sourceClientOffset: t2 || null, clientOffset: e3 || null } };
}
var R = { type: k, payload: { clientOffset: null, sourceClientOffset: null } };
function A(e3) {
  return function(t2 = [], r2 = { publishSource: true }) {
    const { publishSource: n2 = true, clientOffset: o2, getSourceClientOffset: i2 } = r2, s2 = e3.getMonitor(), a2 = e3.getRegistry();
    e3.dispatch(j(o2)), function(e4, t3, r3) {
      E(!t3.isDragging(), "Cannot call beginDrag while dragging."), e4.forEach(function(e5) {
        E(r3.getSource(e5), "Expected sourceIds to be registered.");
      });
    }(t2, s2, a2);
    const c2 = function(e4, t3) {
      let r3 = null;
      for (let n3 = e4.length - 1; n3 >= 0; n3--) if (t3.canDragSource(e4[n3])) {
        r3 = e4[n3];
        break;
      }
      return r3;
    }(t2, s2);
    if (null == c2) return void e3.dispatch(R);
    let l2 = null;
    if (o2) {
      if (!i2) throw new Error("getSourceClientOffset must be defined");
      !function(e4) {
        E("function" == typeof e4, "When clientOffset is provided, getSourceClientOffset must be a function.");
      }(i2), l2 = i2(c2);
    }
    e3.dispatch(j(o2, l2));
    const u2 = a2.getSource(c2).beginDrag(s2, c2);
    if (null == u2) return;
    !function(e4) {
      E(I(e4), "Item must be an object.");
    }(u2), a2.pinSource(c2);
    const d2 = a2.getSourceType(c2);
    return { type: L, payload: { itemType: d2, item: u2, sourceId: c2, clientOffset: o2 || null, sourceClientOffset: l2 || null, isSourcePublic: !!n2 } };
  };
}
function q(e3, t2, r2) {
  return t2 in e3 ? Object.defineProperty(e3, t2, { value: r2, enumerable: true, configurable: true, writable: true }) : e3[t2] = r2, e3;
}
function _(e3) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var r2 = null != arguments[t2] ? arguments[t2] : {}, n2 = Object.keys(r2);
    "function" == typeof Object.getOwnPropertySymbols && (n2 = n2.concat(Object.getOwnPropertySymbols(r2).filter(function(e4) {
      return Object.getOwnPropertyDescriptor(r2, e4).enumerable;
    }))), n2.forEach(function(t3) {
      q(e3, t3, r2[t3]);
    });
  }
  return e3;
}
function H(e3) {
  return function(t2 = {}) {
    const r2 = e3.getMonitor(), n2 = e3.getRegistry();
    !function(e4) {
      E(e4.isDragging(), "Cannot call drop while not dragging."), E(!e4.didDrop(), "Cannot call drop twice during one drag operation.");
    }(r2);
    const o2 = function(e4) {
      const t3 = e4.getTargetIds().filter(e4.canDropOnTarget, e4);
      return t3.reverse(), t3;
    }(r2);
    o2.forEach((o3, i2) => {
      const s2 = function(e4, t3, r3, n3) {
        const o4 = r3.getTarget(e4);
        let i3 = o4 ? o4.drop(n3, e4) : void 0;
        (function(e5) {
          E(void 0 === e5 || I(e5), "Drop result must either be an object or undefined.");
        })(i3), void 0 === i3 && (i3 = 0 === t3 ? {} : n3.getDropResult());
        return i3;
      }(o3, i2, n2, r2), a2 = { type: M, payload: { dropResult: _({}, t2, s2) } };
      e3.dispatch(a2);
    });
  };
}
function z(e3) {
  return function() {
    const t2 = e3.getMonitor(), r2 = e3.getRegistry();
    !function(e4) {
      E(e4.isDragging(), "Cannot call endDrag while not dragging.");
    }(t2);
    const n2 = t2.getSourceId();
    if (null != n2) {
      r2.getSource(n2, true).endDrag(t2, n2), r2.unpinSource();
    }
    return { type: N };
  };
}
function B(e3, t2) {
  return null === t2 ? null === e3 : Array.isArray(e3) ? e3.some((e4) => e4 === t2) : e3 === t2;
}
function W(e3) {
  return function(t2, { clientOffset: r2 } = {}) {
    !function(e4) {
      E(Array.isArray(e4), "Expected targetIds to be an array.");
    }(t2);
    const n2 = t2.slice(0), o2 = e3.getMonitor(), i2 = e3.getRegistry();
    return function(e4, t3, r3) {
      for (let n3 = e4.length - 1; n3 >= 0; n3--) {
        const o3 = e4[n3];
        B(t3.getTargetType(o3), r3) || e4.splice(n3, 1);
      }
    }(n2, i2, o2.getItemType()), function(e4, t3, r3) {
      E(t3.isDragging(), "Cannot call hover while not dragging."), E(!t3.didDrop(), "Cannot call hover after drop.");
      for (let t4 = 0; t4 < e4.length; t4++) {
        const n3 = e4[t4];
        E(e4.lastIndexOf(n3) === t4, "Expected targetIds to be unique in the passed array.");
        E(r3.getTarget(n3), "Expected targetIds to be registered.");
      }
    }(n2, o2, i2), function(e4, t3, r3) {
      e4.forEach(function(e5) {
        r3.getTarget(e5).hover(t3, e5);
      });
    }(n2, o2, i2), { type: x, payload: { targetIds: n2, clientOffset: r2 || null } };
  };
}
function U(e3) {
  return function() {
    if (e3.getMonitor().isDragging()) return { type: P };
  };
}
var F = class {
  receiveBackend(e3) {
    this.backend = e3;
  }
  getMonitor() {
    return this.monitor;
  }
  getBackend() {
    return this.backend;
  }
  getRegistry() {
    return this.monitor.registry;
  }
  getActions() {
    const e3 = this, { dispatch: t2 } = this.store;
    const r2 = function(e4) {
      return { beginDrag: A(e4), publishDragSource: U(e4), hover: W(e4), drop: H(e4), endDrag: z(e4) };
    }(this);
    return Object.keys(r2).reduce((n2, o2) => {
      const i2 = r2[o2];
      var s2;
      return n2[o2] = (s2 = i2, (...r3) => {
        const n3 = s2.apply(e3, r3);
        void 0 !== n3 && t2(n3);
      }), n2;
    }, {});
  }
  dispatch(e3) {
    this.store.dispatch(e3);
  }
  constructor(e3, t2) {
    this.isSetUp = false, this.handleRefCountChange = () => {
      const e4 = this.store.getState().refCount > 0;
      this.backend && (e4 && !this.isSetUp ? (this.backend.setup(), this.isSetUp = true) : !e4 && this.isSetUp && (this.backend.teardown(), this.isSetUp = false));
    }, this.store = e3, this.monitor = t2, e3.subscribe(this.handleRefCountChange);
  }
};
function $(e3, t2) {
  return { x: e3.x - t2.x, y: e3.y - t2.y };
}
var V = [];
var Y = [];
V.__IS_NONE__ = true, Y.__IS_ALL__ = true;
var K = class {
  subscribeToStateChange(e3, t2 = {}) {
    const { handlerIds: r2 } = t2;
    E("function" == typeof e3, "listener must be a function."), E(void 0 === r2 || Array.isArray(r2), "handlerIds, when specified, must be an array of strings.");
    let n2 = this.store.getState().stateId;
    return this.store.subscribe(() => {
      const t3 = this.store.getState(), o2 = t3.stateId;
      try {
        const i2 = o2 === n2 || o2 === n2 + 1 && !function(e4, t4) {
          return e4 !== V && (e4 === Y || void 0 === t4 || (r3 = e4, t4.filter((e5) => r3.indexOf(e5) > -1)).length > 0);
          var r3;
        }(t3.dirtyHandlerIds, r2);
        i2 || e3();
      } finally {
        n2 = o2;
      }
    });
  }
  subscribeToOffsetChange(e3) {
    E("function" == typeof e3, "listener must be a function.");
    let t2 = this.store.getState().dragOffset;
    return this.store.subscribe(() => {
      const r2 = this.store.getState().dragOffset;
      r2 !== t2 && (t2 = r2, e3());
    });
  }
  canDragSource(e3) {
    if (!e3) return false;
    const t2 = this.registry.getSource(e3);
    return E(t2, `Expected to find a valid source. sourceId=${e3}`), !this.isDragging() && t2.canDrag(this, e3);
  }
  canDropOnTarget(e3) {
    if (!e3) return false;
    const t2 = this.registry.getTarget(e3);
    if (E(t2, `Expected to find a valid target. targetId=${e3}`), !this.isDragging() || this.didDrop()) return false;
    return B(this.registry.getTargetType(e3), this.getItemType()) && t2.canDrop(this, e3);
  }
  isDragging() {
    return Boolean(this.getItemType());
  }
  isDraggingSource(e3) {
    if (!e3) return false;
    const t2 = this.registry.getSource(e3, true);
    if (E(t2, `Expected to find a valid source. sourceId=${e3}`), !this.isDragging() || !this.isSourcePublic()) return false;
    return this.registry.getSourceType(e3) === this.getItemType() && t2.isDragging(this, e3);
  }
  isOverTarget(e3, t2 = { shallow: false }) {
    if (!e3) return false;
    const { shallow: r2 } = t2;
    if (!this.isDragging()) return false;
    const n2 = this.registry.getTargetType(e3), o2 = this.getItemType();
    if (o2 && !B(n2, o2)) return false;
    const i2 = this.getTargetIds();
    if (!i2.length) return false;
    const s2 = i2.indexOf(e3);
    return r2 ? s2 === i2.length - 1 : s2 > -1;
  }
  getItemType() {
    return this.store.getState().dragOperation.itemType;
  }
  getItem() {
    return this.store.getState().dragOperation.item;
  }
  getSourceId() {
    return this.store.getState().dragOperation.sourceId;
  }
  getTargetIds() {
    return this.store.getState().dragOperation.targetIds;
  }
  getDropResult() {
    return this.store.getState().dragOperation.dropResult;
  }
  didDrop() {
    return this.store.getState().dragOperation.didDrop;
  }
  isSourcePublic() {
    return Boolean(this.store.getState().dragOperation.isSourcePublic);
  }
  getInitialClientOffset() {
    return this.store.getState().dragOffset.initialClientOffset;
  }
  getInitialSourceClientOffset() {
    return this.store.getState().dragOffset.initialSourceClientOffset;
  }
  getClientOffset() {
    return this.store.getState().dragOffset.clientOffset;
  }
  getSourceClientOffset() {
    return function(e3) {
      const { clientOffset: t2, initialClientOffset: r2, initialSourceClientOffset: n2 } = e3;
      return t2 && r2 && n2 ? $((i2 = n2, { x: (o2 = t2).x + i2.x, y: o2.y + i2.y }), r2) : null;
      var o2, i2;
    }(this.store.getState().dragOffset);
  }
  getDifferenceFromInitialOffset() {
    return function(e3) {
      const { clientOffset: t2, initialClientOffset: r2 } = e3;
      return t2 && r2 ? $(t2, r2) : null;
    }(this.store.getState().dragOffset);
  }
  constructor(e3, t2) {
    this.store = e3, this.registry = t2;
  }
};
var X = "undefined" != typeof global ? global : self;
var G = X.MutationObserver || X.WebKitMutationObserver;
function Q(e3) {
  return function() {
    const t2 = setTimeout(n2, 0), r2 = setInterval(n2, 50);
    function n2() {
      clearTimeout(t2), clearInterval(r2), e3();
    }
  };
}
var J = "function" == typeof G ? function(e3) {
  let t2 = 1;
  const r2 = new G(e3), n2 = document.createTextNode("");
  return r2.observe(n2, { characterData: true }), function() {
    t2 = -t2, n2.data = t2;
  };
} : Q;
var Z = class {
  call() {
    try {
      this.task && this.task();
    } catch (e3) {
      this.onError(e3);
    } finally {
      this.task = null, this.release(this);
    }
  }
  constructor(e3, t2) {
    this.onError = e3, this.release = t2, this.task = null;
  }
};
var ee = new class {
  enqueueTask(e3) {
    const { queue: t2, requestFlush: r2 } = this;
    t2.length || (r2(), this.flushing = true), t2[t2.length] = e3;
  }
  constructor() {
    this.queue = [], this.pendingErrors = [], this.flushing = false, this.index = 0, this.capacity = 1024, this.flush = () => {
      const { queue: e3 } = this;
      for (; this.index < e3.length; ) {
        const t2 = this.index;
        if (this.index++, e3[t2].call(), this.index > this.capacity) {
          for (let t3 = 0, r2 = e3.length - this.index; t3 < r2; t3++) e3[t3] = e3[t3 + this.index];
          e3.length -= this.index, this.index = 0;
        }
      }
      e3.length = 0, this.index = 0, this.flushing = false;
    }, this.registerPendingError = (e3) => {
      this.pendingErrors.push(e3), this.requestErrorThrow();
    }, this.requestFlush = J(this.flush), this.requestErrorThrow = Q(() => {
      if (this.pendingErrors.length) throw this.pendingErrors.shift();
    });
  }
}();
var te = new class {
  create(e3) {
    const t2 = this.freeTasks, r2 = t2.length ? t2.pop() : new Z(this.onError, (e4) => t2[t2.length] = e4);
    return r2.task = e3, r2;
  }
  constructor(e3) {
    this.onError = e3, this.freeTasks = [];
  }
}(ee.registerPendingError);
var re = "dnd-core/ADD_SOURCE";
var ne = "dnd-core/ADD_TARGET";
var oe = "dnd-core/REMOVE_SOURCE";
var ie = "dnd-core/REMOVE_TARGET";
function se(e3, t2) {
  t2 && Array.isArray(e3) ? e3.forEach((e4) => se(e4, false)) : E("string" == typeof e3 || "symbol" == typeof e3, t2 ? "Type can only be a string, a symbol, or an array of either." : "Type can only be a string or a symbol.");
}
var ae;
!function(e3) {
  e3.SOURCE = "SOURCE", e3.TARGET = "TARGET";
}(ae || (ae = {}));
var ce = 0;
function le(e3) {
  const t2 = (ce++).toString();
  switch (e3) {
    case ae.SOURCE:
      return `S${t2}`;
    case ae.TARGET:
      return `T${t2}`;
    default:
      throw new Error(`Unknown Handler Role: ${e3}`);
  }
}
function ue(e3) {
  switch (e3[0]) {
    case "S":
      return ae.SOURCE;
    case "T":
      return ae.TARGET;
    default:
      throw new Error(`Cannot parse handler ID: ${e3}`);
  }
}
function de(e3, t2) {
  const r2 = e3.entries();
  let n2 = false;
  do {
    const { done: e4, value: [, o2] } = r2.next();
    if (o2 === t2) return true;
    n2 = !!e4;
  } while (!n2);
  return false;
}
var he = class {
  addSource(e3, t2) {
    se(e3), function(e4) {
      E("function" == typeof e4.canDrag, "Expected canDrag to be a function."), E("function" == typeof e4.beginDrag, "Expected beginDrag to be a function."), E("function" == typeof e4.endDrag, "Expected endDrag to be a function.");
    }(t2);
    const r2 = this.addHandler(ae.SOURCE, e3, t2);
    return this.store.dispatch(/* @__PURE__ */ function(e4) {
      return { type: re, payload: { sourceId: e4 } };
    }(r2)), r2;
  }
  addTarget(e3, t2) {
    se(e3, true), function(e4) {
      E("function" == typeof e4.canDrop, "Expected canDrop to be a function."), E("function" == typeof e4.hover, "Expected hover to be a function."), E("function" == typeof e4.drop, "Expected beginDrag to be a function.");
    }(t2);
    const r2 = this.addHandler(ae.TARGET, e3, t2);
    return this.store.dispatch(/* @__PURE__ */ function(e4) {
      return { type: ne, payload: { targetId: e4 } };
    }(r2)), r2;
  }
  containsHandler(e3) {
    return de(this.dragSources, e3) || de(this.dropTargets, e3);
  }
  getSource(e3, t2 = false) {
    E(this.isSourceId(e3), "Expected a valid source ID.");
    return t2 && e3 === this.pinnedSourceId ? this.pinnedSource : this.dragSources.get(e3);
  }
  getTarget(e3) {
    return E(this.isTargetId(e3), "Expected a valid target ID."), this.dropTargets.get(e3);
  }
  getSourceType(e3) {
    return E(this.isSourceId(e3), "Expected a valid source ID."), this.types.get(e3);
  }
  getTargetType(e3) {
    return E(this.isTargetId(e3), "Expected a valid target ID."), this.types.get(e3);
  }
  isSourceId(e3) {
    return ue(e3) === ae.SOURCE;
  }
  isTargetId(e3) {
    return ue(e3) === ae.TARGET;
  }
  removeSource(e3) {
    var t2;
    E(this.getSource(e3), "Expected an existing source."), this.store.dispatch(/* @__PURE__ */ function(e4) {
      return { type: oe, payload: { sourceId: e4 } };
    }(e3)), t2 = () => {
      this.dragSources.delete(e3), this.types.delete(e3);
    }, ee.enqueueTask(te.create(t2));
  }
  removeTarget(e3) {
    E(this.getTarget(e3), "Expected an existing target."), this.store.dispatch(/* @__PURE__ */ function(e4) {
      return { type: ie, payload: { targetId: e4 } };
    }(e3)), this.dropTargets.delete(e3), this.types.delete(e3);
  }
  pinSource(e3) {
    const t2 = this.getSource(e3);
    E(t2, "Expected an existing source."), this.pinnedSourceId = e3, this.pinnedSource = t2;
  }
  unpinSource() {
    E(this.pinnedSource, "No source is pinned at the time."), this.pinnedSourceId = null, this.pinnedSource = null;
  }
  addHandler(e3, t2, r2) {
    const n2 = le(e3);
    return this.types.set(n2, t2), e3 === ae.SOURCE ? this.dragSources.set(n2, r2) : e3 === ae.TARGET && this.dropTargets.set(n2, r2), n2;
  }
  constructor(e3) {
    this.types = /* @__PURE__ */ new Map(), this.dragSources = /* @__PURE__ */ new Map(), this.dropTargets = /* @__PURE__ */ new Map(), this.pinnedSourceId = null, this.pinnedSource = null, this.store = e3;
  }
};
var ge = (e3, t2) => e3 === t2;
function fe(e3 = V, t2) {
  switch (t2.type) {
    case x:
      break;
    case re:
    case ne:
    case ie:
    case oe:
      return V;
    default:
      return Y;
  }
  const { targetIds: r2 = [], prevTargetIds: n2 = [] } = t2.payload, o2 = function(e4, t3) {
    const r3 = /* @__PURE__ */ new Map(), n3 = (e5) => {
      r3.set(e5, r3.has(e5) ? r3.get(e5) + 1 : 1);
    };
    e4.forEach(n3), t3.forEach(n3);
    const o3 = [];
    return r3.forEach((e5, t4) => {
      1 === e5 && o3.push(t4);
    }), o3;
  }(r2, n2);
  if (!(o2.length > 0 || !function(e4, t3, r3 = ge) {
    if (e4.length !== t3.length) return false;
    for (let n3 = 0; n3 < e4.length; ++n3) if (!r3(e4[n3], t3[n3])) return false;
    return true;
  }(r2, n2))) return V;
  const i2 = n2[n2.length - 1], s2 = r2[r2.length - 1];
  return i2 !== s2 && (i2 && o2.push(i2), s2 && o2.push(s2)), o2;
}
function pe(e3, t2, r2) {
  return t2 in e3 ? Object.defineProperty(e3, t2, { value: r2, enumerable: true, configurable: true, writable: true }) : e3[t2] = r2, e3;
}
var ve = { initialSourceClientOffset: null, initialClientOffset: null, clientOffset: null };
function me(e3 = ve, t2) {
  const { payload: r2 } = t2;
  switch (t2.type) {
    case k:
    case L:
      return { initialSourceClientOffset: r2.sourceClientOffset, initialClientOffset: r2.clientOffset, clientOffset: r2.clientOffset };
    case x:
      return n2 = e3.clientOffset, o2 = r2.clientOffset, !n2 && !o2 || n2 && o2 && n2.x === o2.x && n2.y === o2.y ? e3 : function(e4) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var r3 = null != arguments[t3] ? arguments[t3] : {}, n3 = Object.keys(r3);
          "function" == typeof Object.getOwnPropertySymbols && (n3 = n3.concat(Object.getOwnPropertySymbols(r3).filter(function(e5) {
            return Object.getOwnPropertyDescriptor(r3, e5).enumerable;
          }))), n3.forEach(function(t4) {
            pe(e4, t4, r3[t4]);
          });
        }
        return e4;
      }({}, e3, { clientOffset: r2.clientOffset });
    case N:
    case M:
      return ve;
    default:
      return e3;
  }
  var n2, o2;
}
function ye(e3, t2, r2) {
  return t2 in e3 ? Object.defineProperty(e3, t2, { value: r2, enumerable: true, configurable: true, writable: true }) : e3[t2] = r2, e3;
}
function be(e3) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var r2 = null != arguments[t2] ? arguments[t2] : {}, n2 = Object.keys(r2);
    "function" == typeof Object.getOwnPropertySymbols && (n2 = n2.concat(Object.getOwnPropertySymbols(r2).filter(function(e4) {
      return Object.getOwnPropertyDescriptor(r2, e4).enumerable;
    }))), n2.forEach(function(t3) {
      ye(e3, t3, r2[t3]);
    });
  }
  return e3;
}
var Oe = { itemType: null, item: null, sourceId: null, targetIds: [], dropResult: null, didDrop: false, isSourcePublic: null };
function we(e3 = Oe, t2) {
  const { payload: r2 } = t2;
  switch (t2.type) {
    case L:
      return be({}, e3, { itemType: r2.itemType, item: r2.item, sourceId: r2.sourceId, isSourcePublic: r2.isSourcePublic, dropResult: null, didDrop: false });
    case P:
      return be({}, e3, { isSourcePublic: true });
    case x:
      return be({}, e3, { targetIds: r2.targetIds });
    case ie:
      return -1 === e3.targetIds.indexOf(r2.targetId) ? e3 : be({}, e3, { targetIds: (n2 = e3.targetIds, o2 = r2.targetId, n2.filter((e4) => e4 !== o2)) });
    case M:
      return be({}, e3, { dropResult: r2.dropResult, didDrop: true, targetIds: [] });
    case N:
      return be({}, e3, { itemType: null, item: null, sourceId: null, dropResult: null, didDrop: false, isSourcePublic: null, targetIds: [] });
    default:
      return e3;
  }
  var n2, o2;
}
function Se(e3 = 0, t2) {
  switch (t2.type) {
    case re:
    case ne:
      return e3 + 1;
    case oe:
    case ie:
      return e3 - 1;
    default:
      return e3;
  }
}
function De(e3 = 0) {
  return e3 + 1;
}
function Ce(e3, t2, r2) {
  return t2 in e3 ? Object.defineProperty(e3, t2, { value: r2, enumerable: true, configurable: true, writable: true }) : e3[t2] = r2, e3;
}
function Te(e3) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var r2 = null != arguments[t2] ? arguments[t2] : {}, n2 = Object.keys(r2);
    "function" == typeof Object.getOwnPropertySymbols && (n2 = n2.concat(Object.getOwnPropertySymbols(r2).filter(function(e4) {
      return Object.getOwnPropertyDescriptor(r2, e4).enumerable;
    }))), n2.forEach(function(t3) {
      Ce(e3, t3, r2[t3]);
    });
  }
  return e3;
}
function Ee(e3 = {}, t2) {
  return { dirtyHandlerIds: fe(e3.dirtyHandlerIds, { type: t2.type, payload: Te({}, t2.payload, { prevTargetIds: (r2 = e3, n2 = "dragOperation.targetIds", o2 = [], n2.split(".").reduce((e4, t3) => e4 && e4[t3] ? e4[t3] : o2 || null, r2)) }) }), dragOffset: me(e3.dragOffset, t2), refCount: Se(e3.refCount, t2), dragOperation: we(e3.dragOperation, t2), stateId: De(e3.stateId) };
  var r2, n2, o2;
}
function Ie(e3, t2 = void 0, r2 = {}, n2 = false) {
  const o2 = function(e4) {
    const t3 = "undefined" != typeof window && window.__REDUX_DEVTOOLS_EXTENSION__;
    return C(Ee, e4 && t3 && t3({ name: "dnd-core", instanceId: "dnd-core" }));
  }(n2), i2 = new K(o2, new he(o2)), s2 = new F(o2, i2), a2 = e3(s2, t2, r2);
  return s2.receiveBackend(a2), s2;
}
function ke(e3, t2) {
  if (null == e3) return {};
  var r2, n2, o2 = function(e4, t3) {
    if (null == e4) return {};
    var r3, n3, o3 = {}, i3 = Object.keys(e4);
    for (n3 = 0; n3 < i3.length; n3++) r3 = i3[n3], t3.indexOf(r3) >= 0 || (o3[r3] = e4[r3]);
    return o3;
  }(e3, t2);
  if (Object.getOwnPropertySymbols) {
    var i2 = Object.getOwnPropertySymbols(e3);
    for (n2 = 0; n2 < i2.length; n2++) r2 = i2[n2], t2.indexOf(r2) >= 0 || Object.prototype.propertyIsEnumerable.call(e3, r2) && (o2[r2] = e3[r2]);
  }
  return o2;
}
var Le = 0;
var Pe = Symbol.for("__REACT_DND_CONTEXT_INSTANCE__");
var xe = (0, import_react.memo)(function(t2) {
  var { children: r2 } = t2, n2 = ke(t2, ["children"]);
  const [o2, s2] = function(e3) {
    if ("manager" in e3) {
      return [{ dragDropManager: e3.manager }, false];
    }
    const t3 = function(e4, t4 = Me(), r4, n3) {
      const o3 = t4;
      o3[Pe] || (o3[Pe] = { dragDropManager: Ie(e4, t4, r4, n3) });
      return o3[Pe];
    }(e3.backend, e3.context, e3.options, e3.debugMode), r3 = !e3.context;
    return [t3, r3];
  }(n2);
  return (0, import_react.useEffect)(() => {
    if (s2) {
      const e3 = Me();
      return ++Le, () => {
        0 == --Le && (e3[Pe] = null);
      };
    }
  }, []), (0, import_jsx_runtime.jsx)(m.Provider, { value: o2, children: r2 });
});
function Me() {
  return "undefined" != typeof global ? global : window;
}
var Ne = function e2(t2, r2) {
  if (t2 === r2) return true;
  if (t2 && r2 && "object" == typeof t2 && "object" == typeof r2) {
    if (t2.constructor !== r2.constructor) return false;
    var n2, o2, i2;
    if (Array.isArray(t2)) {
      if ((n2 = t2.length) != r2.length) return false;
      for (o2 = n2; 0 != o2--; ) if (!e2(t2[o2], r2[o2])) return false;
      return true;
    }
    if (t2.constructor === RegExp) return t2.source === r2.source && t2.flags === r2.flags;
    if (t2.valueOf !== Object.prototype.valueOf) return t2.valueOf() === r2.valueOf();
    if (t2.toString !== Object.prototype.toString) return t2.toString() === r2.toString();
    if ((n2 = (i2 = Object.keys(t2)).length) !== Object.keys(r2).length) return false;
    for (o2 = n2; 0 != o2--; ) if (!Object.prototype.hasOwnProperty.call(r2, i2[o2])) return false;
    for (o2 = n2; 0 != o2--; ) {
      var s2 = i2[o2];
      if (!e2(t2[s2], r2[s2])) return false;
    }
    return true;
  }
  return t2 != t2 && r2 != r2;
};
var je = "undefined" != typeof window ? import_react.useLayoutEffect : import_react.useEffect;
function Re(e3, t2, r2) {
  const [n2, o2] = (0, import_react.useState)(() => t2(e3)), i2 = (0, import_react.useCallback)(() => {
    const i3 = t2(e3);
    Ne(n2, i3) || (o2(i3), r2 && r2());
  }, [n2, e3, r2]);
  return je(i2), [n2, i2];
}
function Ae(e3, t2, r2) {
  return function(e4, t3, r3) {
    const [n2, o2] = Re(e4, t3, r3);
    return je(function() {
      const t4 = e4.getHandlerId();
      if (null != t4) return e4.subscribeToStateChange(o2, { handlerIds: [t4] });
    }, [e4, o2]), n2;
  }(t2, e3 || (() => ({})), () => r2.reconnect());
}
function qe(e3, t2) {
  const r2 = [...t2 || []];
  return null == t2 && "function" != typeof e3 && r2.push(e3), (0, import_react.useMemo)(() => "function" == typeof e3 ? e3() : e3, r2);
}
function _e(e3) {
  return (0, import_react.useMemo)(() => e3.hooks.dragSource(), [e3]);
}
function He(e3) {
  return (0, import_react.useMemo)(() => e3.hooks.dragPreview(), [e3]);
}
var ze = false;
var Be = false;
var We = class {
  receiveHandlerId(e3) {
    this.sourceId = e3;
  }
  getHandlerId() {
    return this.sourceId;
  }
  canDrag() {
    E(!ze, "You may not call monitor.canDrag() inside your canDrag() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor");
    try {
      return ze = true, this.internalMonitor.canDragSource(this.sourceId);
    } finally {
      ze = false;
    }
  }
  isDragging() {
    if (!this.sourceId) return false;
    E(!Be, "You may not call monitor.isDragging() inside your isDragging() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor");
    try {
      return Be = true, this.internalMonitor.isDraggingSource(this.sourceId);
    } finally {
      Be = false;
    }
  }
  subscribeToStateChange(e3, t2) {
    return this.internalMonitor.subscribeToStateChange(e3, t2);
  }
  isDraggingSource(e3) {
    return this.internalMonitor.isDraggingSource(e3);
  }
  isOverTarget(e3, t2) {
    return this.internalMonitor.isOverTarget(e3, t2);
  }
  getTargetIds() {
    return this.internalMonitor.getTargetIds();
  }
  isSourcePublic() {
    return this.internalMonitor.isSourcePublic();
  }
  getSourceId() {
    return this.internalMonitor.getSourceId();
  }
  subscribeToOffsetChange(e3) {
    return this.internalMonitor.subscribeToOffsetChange(e3);
  }
  canDragSource(e3) {
    return this.internalMonitor.canDragSource(e3);
  }
  canDropOnTarget(e3) {
    return this.internalMonitor.canDropOnTarget(e3);
  }
  getItemType() {
    return this.internalMonitor.getItemType();
  }
  getItem() {
    return this.internalMonitor.getItem();
  }
  getDropResult() {
    return this.internalMonitor.getDropResult();
  }
  didDrop() {
    return this.internalMonitor.didDrop();
  }
  getInitialClientOffset() {
    return this.internalMonitor.getInitialClientOffset();
  }
  getInitialSourceClientOffset() {
    return this.internalMonitor.getInitialSourceClientOffset();
  }
  getSourceClientOffset() {
    return this.internalMonitor.getSourceClientOffset();
  }
  getClientOffset() {
    return this.internalMonitor.getClientOffset();
  }
  getDifferenceFromInitialOffset() {
    return this.internalMonitor.getDifferenceFromInitialOffset();
  }
  constructor(e3) {
    this.sourceId = null, this.internalMonitor = e3.getMonitor();
  }
};
var Ue = false;
var Fe = class {
  receiveHandlerId(e3) {
    this.targetId = e3;
  }
  getHandlerId() {
    return this.targetId;
  }
  subscribeToStateChange(e3, t2) {
    return this.internalMonitor.subscribeToStateChange(e3, t2);
  }
  canDrop() {
    if (!this.targetId) return false;
    E(!Ue, "You may not call monitor.canDrop() inside your canDrop() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target-monitor");
    try {
      return Ue = true, this.internalMonitor.canDropOnTarget(this.targetId);
    } finally {
      Ue = false;
    }
  }
  isOver(e3) {
    return !!this.targetId && this.internalMonitor.isOverTarget(this.targetId, e3);
  }
  getItemType() {
    return this.internalMonitor.getItemType();
  }
  getItem() {
    return this.internalMonitor.getItem();
  }
  getDropResult() {
    return this.internalMonitor.getDropResult();
  }
  didDrop() {
    return this.internalMonitor.didDrop();
  }
  getInitialClientOffset() {
    return this.internalMonitor.getInitialClientOffset();
  }
  getInitialSourceClientOffset() {
    return this.internalMonitor.getInitialSourceClientOffset();
  }
  getSourceClientOffset() {
    return this.internalMonitor.getSourceClientOffset();
  }
  getClientOffset() {
    return this.internalMonitor.getClientOffset();
  }
  getDifferenceFromInitialOffset() {
    return this.internalMonitor.getDifferenceFromInitialOffset();
  }
  constructor(e3) {
    this.targetId = null, this.internalMonitor = e3.getMonitor();
  }
};
function $e(e3, t2, r2, n2) {
  let o2 = r2 ? r2.call(n2, e3, t2) : void 0;
  if (void 0 !== o2) return !!o2;
  if (e3 === t2) return true;
  if ("object" != typeof e3 || !e3 || "object" != typeof t2 || !t2) return false;
  const i2 = Object.keys(e3), s2 = Object.keys(t2);
  if (i2.length !== s2.length) return false;
  const a2 = Object.prototype.hasOwnProperty.bind(t2);
  for (let s3 = 0; s3 < i2.length; s3++) {
    const c2 = i2[s3];
    if (!a2(c2)) return false;
    const l2 = e3[c2], u2 = t2[c2];
    if (o2 = r2 ? r2.call(n2, l2, u2, c2) : void 0, false === o2 || void 0 === o2 && l2 !== u2) return false;
  }
  return true;
}
function Ve(e3) {
  return null !== e3 && "object" == typeof e3 && Object.prototype.hasOwnProperty.call(e3, "current");
}
function Ye(e3) {
  return (t2 = null, r2 = null) => {
    if (!(0, import_react.isValidElement)(t2)) {
      const n3 = t2;
      return e3(n3, r2), n3;
    }
    const n2 = t2;
    !function(e4) {
      if ("string" == typeof e4.type) return;
      const t3 = e4.type.displayName || e4.type.name || "the component";
      throw new Error(`Only native element nodes can now be passed to React DnD connectors.You can either wrap ${t3} into a <div>, or turn it into a drag source or a drop target itself.`);
    }(n2);
    return function(e4, t3) {
      const r3 = e4.ref;
      return E("string" != typeof r3, "Cannot connect React DnD to an element with an existing string ref. Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs"), (0, import_react.cloneElement)(e4, r3 ? { ref: (e5) => {
        Xe(r3, e5), Xe(t3, e5);
      } } : { ref: t3 });
    }(n2, r2 ? (t3) => e3(t3, r2) : e3);
  };
}
function Ke(e3) {
  const t2 = {};
  return Object.keys(e3).forEach((r2) => {
    const n2 = e3[r2];
    if (r2.endsWith("Ref")) t2[r2] = e3[r2];
    else {
      const e4 = Ye(n2);
      t2[r2] = () => e4;
    }
  }), t2;
}
function Xe(e3, t2) {
  "function" == typeof e3 ? e3(t2) : e3.current = t2;
}
var Ge = class {
  receiveHandlerId(e3) {
    this.handlerId !== e3 && (this.handlerId = e3, this.reconnect());
  }
  get connectTarget() {
    return this.dragSource;
  }
  get dragSourceOptions() {
    return this.dragSourceOptionsInternal;
  }
  set dragSourceOptions(e3) {
    this.dragSourceOptionsInternal = e3;
  }
  get dragPreviewOptions() {
    return this.dragPreviewOptionsInternal;
  }
  set dragPreviewOptions(e3) {
    this.dragPreviewOptionsInternal = e3;
  }
  reconnect() {
    const e3 = this.reconnectDragSource();
    this.reconnectDragPreview(e3);
  }
  reconnectDragSource() {
    const e3 = this.dragSource, t2 = this.didHandlerIdChange() || this.didConnectedDragSourceChange() || this.didDragSourceOptionsChange();
    return t2 && this.disconnectDragSource(), this.handlerId ? e3 ? (t2 && (this.lastConnectedHandlerId = this.handlerId, this.lastConnectedDragSource = e3, this.lastConnectedDragSourceOptions = this.dragSourceOptions, this.dragSourceUnsubscribe = this.backend.connectDragSource(this.handlerId, e3, this.dragSourceOptions)), t2) : (this.lastConnectedDragSource = e3, t2) : t2;
  }
  reconnectDragPreview(e3 = false) {
    const t2 = this.dragPreview, r2 = e3 || this.didHandlerIdChange() || this.didConnectedDragPreviewChange() || this.didDragPreviewOptionsChange();
    r2 && this.disconnectDragPreview(), this.handlerId && (t2 ? r2 && (this.lastConnectedHandlerId = this.handlerId, this.lastConnectedDragPreview = t2, this.lastConnectedDragPreviewOptions = this.dragPreviewOptions, this.dragPreviewUnsubscribe = this.backend.connectDragPreview(this.handlerId, t2, this.dragPreviewOptions)) : this.lastConnectedDragPreview = t2);
  }
  didHandlerIdChange() {
    return this.lastConnectedHandlerId !== this.handlerId;
  }
  didConnectedDragSourceChange() {
    return this.lastConnectedDragSource !== this.dragSource;
  }
  didConnectedDragPreviewChange() {
    return this.lastConnectedDragPreview !== this.dragPreview;
  }
  didDragSourceOptionsChange() {
    return !$e(this.lastConnectedDragSourceOptions, this.dragSourceOptions);
  }
  didDragPreviewOptionsChange() {
    return !$e(this.lastConnectedDragPreviewOptions, this.dragPreviewOptions);
  }
  disconnectDragSource() {
    this.dragSourceUnsubscribe && (this.dragSourceUnsubscribe(), this.dragSourceUnsubscribe = void 0);
  }
  disconnectDragPreview() {
    this.dragPreviewUnsubscribe && (this.dragPreviewUnsubscribe(), this.dragPreviewUnsubscribe = void 0, this.dragPreviewNode = null, this.dragPreviewRef = null);
  }
  get dragSource() {
    return this.dragSourceNode || this.dragSourceRef && this.dragSourceRef.current;
  }
  get dragPreview() {
    return this.dragPreviewNode || this.dragPreviewRef && this.dragPreviewRef.current;
  }
  clearDragSource() {
    this.dragSourceNode = null, this.dragSourceRef = null;
  }
  clearDragPreview() {
    this.dragPreviewNode = null, this.dragPreviewRef = null;
  }
  constructor(e3) {
    this.hooks = Ke({ dragSource: (e4, t2) => {
      this.clearDragSource(), this.dragSourceOptions = t2 || null, Ve(e4) ? this.dragSourceRef = e4 : this.dragSourceNode = e4, this.reconnectDragSource();
    }, dragPreview: (e4, t2) => {
      this.clearDragPreview(), this.dragPreviewOptions = t2 || null, Ve(e4) ? this.dragPreviewRef = e4 : this.dragPreviewNode = e4, this.reconnectDragPreview();
    } }), this.handlerId = null, this.dragSourceRef = null, this.dragSourceOptionsInternal = null, this.dragPreviewRef = null, this.dragPreviewOptionsInternal = null, this.lastConnectedHandlerId = null, this.lastConnectedDragSource = null, this.lastConnectedDragSourceOptions = null, this.lastConnectedDragPreview = null, this.lastConnectedDragPreviewOptions = null, this.backend = e3;
  }
};
var Qe = class {
  get connectTarget() {
    return this.dropTarget;
  }
  reconnect() {
    const e3 = this.didHandlerIdChange() || this.didDropTargetChange() || this.didOptionsChange();
    e3 && this.disconnectDropTarget();
    const t2 = this.dropTarget;
    this.handlerId && (t2 ? e3 && (this.lastConnectedHandlerId = this.handlerId, this.lastConnectedDropTarget = t2, this.lastConnectedDropTargetOptions = this.dropTargetOptions, this.unsubscribeDropTarget = this.backend.connectDropTarget(this.handlerId, t2, this.dropTargetOptions)) : this.lastConnectedDropTarget = t2);
  }
  receiveHandlerId(e3) {
    e3 !== this.handlerId && (this.handlerId = e3, this.reconnect());
  }
  get dropTargetOptions() {
    return this.dropTargetOptionsInternal;
  }
  set dropTargetOptions(e3) {
    this.dropTargetOptionsInternal = e3;
  }
  didHandlerIdChange() {
    return this.lastConnectedHandlerId !== this.handlerId;
  }
  didDropTargetChange() {
    return this.lastConnectedDropTarget !== this.dropTarget;
  }
  didOptionsChange() {
    return !$e(this.lastConnectedDropTargetOptions, this.dropTargetOptions);
  }
  disconnectDropTarget() {
    this.unsubscribeDropTarget && (this.unsubscribeDropTarget(), this.unsubscribeDropTarget = void 0);
  }
  get dropTarget() {
    return this.dropTargetNode || this.dropTargetRef && this.dropTargetRef.current;
  }
  clearDropTarget() {
    this.dropTargetRef = null, this.dropTargetNode = null;
  }
  constructor(e3) {
    this.hooks = Ke({ dropTarget: (e4, t2) => {
      this.clearDropTarget(), this.dropTargetOptions = t2, Ve(e4) ? this.dropTargetRef = e4 : this.dropTargetNode = e4, this.reconnect();
    } }), this.handlerId = null, this.dropTargetRef = null, this.dropTargetOptionsInternal = null, this.lastConnectedHandlerId = null, this.lastConnectedDropTarget = null, this.lastConnectedDropTargetOptions = null, this.backend = e3;
  }
};
function Je() {
  const { dragDropManager: e3 } = (0, import_react.useContext)(m);
  return E(null != e3, "Expected drag drop context"), e3;
}
var Ze = class {
  beginDrag() {
    const e3 = this.spec, t2 = this.monitor;
    let r2 = null;
    return r2 = "object" == typeof e3.item ? e3.item : "function" == typeof e3.item ? e3.item(t2) : {}, null != r2 ? r2 : null;
  }
  canDrag() {
    const e3 = this.spec, t2 = this.monitor;
    return "boolean" == typeof e3.canDrag ? e3.canDrag : "function" != typeof e3.canDrag || e3.canDrag(t2);
  }
  isDragging(e3, t2) {
    const r2 = this.spec, n2 = this.monitor, { isDragging: o2 } = r2;
    return o2 ? o2(n2) : t2 === e3.getSourceId();
  }
  endDrag() {
    const e3 = this.spec, t2 = this.monitor, r2 = this.connector, { end: n2 } = e3;
    n2 && n2(t2.getItem(), t2), r2.reconnect();
  }
  constructor(e3, t2, r2) {
    this.spec = e3, this.monitor = t2, this.connector = r2;
  }
};
function et(e3, t2, r2) {
  const n2 = Je(), o2 = function(e4, t3, r3) {
    const n3 = (0, import_react.useMemo)(() => new Ze(e4, t3, r3), [t3, r3]);
    return (0, import_react.useEffect)(() => {
      n3.spec = e4;
    }, [e4]), n3;
  }(e3, t2, r2), s2 = function(e4) {
    return (0, import_react.useMemo)(() => {
      const t3 = e4.type;
      return E(null != t3, "spec.type must be defined"), t3;
    }, [e4]);
  }(e3);
  je(function() {
    if (null != s2) {
      const [e4, i2] = function(e5, t3, r3) {
        const n3 = r3.getRegistry(), o3 = n3.addSource(e5, t3);
        return [o3, () => n3.removeSource(o3)];
      }(s2, o2, n2);
      return t2.receiveHandlerId(e4), r2.receiveHandlerId(e4), i2;
    }
  }, [n2, t2, r2, o2, s2]);
}
function tt(e3, t2) {
  const r2 = qe(e3, t2);
  E(!r2.begin, "useDrag::spec.begin was deprecated in v14. Replace spec.begin() with spec.item(). (see more here - https://react-dnd.github.io/react-dnd/docs/api/use-drag)");
  const n2 = function() {
    const e4 = Je();
    return (0, import_react.useMemo)(() => new We(e4), [e4]);
  }(), o2 = function(e4, t3) {
    const r3 = Je(), n3 = (0, import_react.useMemo)(() => new Ge(r3.getBackend()), [r3]);
    return je(() => (n3.dragSourceOptions = e4 || null, n3.reconnect(), () => n3.disconnectDragSource()), [n3, e4]), je(() => (n3.dragPreviewOptions = t3 || null, n3.reconnect(), () => n3.disconnectDragPreview()), [n3, t3]), n3;
  }(r2.options, r2.previewOptions);
  return et(r2, n2, o2), [Ae(r2.collect, n2, o2), _e(o2), He(o2)];
}
function rt(e3) {
  return (0, import_react.useMemo)(() => e3.hooks.dropTarget(), [e3]);
}
var nt = class {
  canDrop() {
    const e3 = this.spec, t2 = this.monitor;
    return !e3.canDrop || e3.canDrop(t2.getItem(), t2);
  }
  hover() {
    const e3 = this.spec, t2 = this.monitor;
    e3.hover && e3.hover(t2.getItem(), t2);
  }
  drop() {
    const e3 = this.spec, t2 = this.monitor;
    if (e3.drop) return e3.drop(t2.getItem(), t2);
  }
  constructor(e3, t2) {
    this.spec = e3, this.monitor = t2;
  }
};
function ot(e3, t2, r2) {
  const n2 = Je(), o2 = function(e4, t3) {
    const r3 = (0, import_react.useMemo)(() => new nt(e4, t3), [t3]);
    return (0, import_react.useEffect)(() => {
      r3.spec = e4;
    }, [e4]), r3;
  }(e3, t2), s2 = function(e4) {
    const { accept: t3 } = e4;
    return (0, import_react.useMemo)(() => (E(null != e4.accept, "accept must be defined"), Array.isArray(t3) ? t3 : [t3]), [t3]);
  }(e3);
  je(function() {
    const [e4, i2] = function(e5, t3, r3) {
      const n3 = r3.getRegistry(), o3 = n3.addTarget(e5, t3);
      return [o3, () => n3.removeTarget(o3)];
    }(s2, o2, n2);
    return t2.receiveHandlerId(e4), r2.receiveHandlerId(e4), i2;
  }, [n2, t2, o2, r2, s2.map((e4) => e4.toString()).join("|")]);
}
function it(e3, t2) {
  const r2 = qe(e3, t2), n2 = function() {
    const e4 = Je();
    return (0, import_react.useMemo)(() => new Fe(e4), [e4]);
  }(), o2 = function(e4) {
    const t3 = Je(), r3 = (0, import_react.useMemo)(() => new Qe(t3.getBackend()), [t3]);
    return je(() => (r3.dropTargetOptions = e4 || null, r3.reconnect(), () => r3.disconnectDropTarget()), [e4]), r3;
  }(r2.options);
  return ot(r2, n2, o2), [Ae(r2.collect, n2, o2), rt(o2)];
}
function st(e3) {
  let t2 = null;
  return () => (null == t2 && (t2 = e3()), t2);
}
var at = class {
  enter(e3) {
    const t2 = this.entered.length;
    return this.entered = function(e4, t3) {
      const r2 = /* @__PURE__ */ new Set(), n2 = (e5) => r2.add(e5);
      e4.forEach(n2), t3.forEach(n2);
      const o2 = [];
      return r2.forEach((e5) => o2.push(e5)), o2;
    }(this.entered.filter((t3) => this.isNodeInDocument(t3) && (!t3.contains || t3.contains(e3))), [e3]), 0 === t2 && this.entered.length > 0;
  }
  leave(e3) {
    const t2 = this.entered.length;
    var r2, n2;
    return this.entered = (r2 = this.entered.filter(this.isNodeInDocument), n2 = e3, r2.filter((e4) => e4 !== n2)), t2 > 0 && 0 === this.entered.length;
  }
  reset() {
    this.entered = [];
  }
  constructor(e3) {
    this.entered = [], this.isNodeInDocument = e3;
  }
};
var ct = class {
  initializeExposedProperties() {
    Object.keys(this.config.exposeProperties).forEach((e3) => {
      Object.defineProperty(this.item, e3, { configurable: true, enumerable: true, get: () => (console.warn(`Browser doesn't allow reading "${e3}" until the drop event.`), null) });
    });
  }
  loadDataTransfer(e3) {
    if (e3) {
      const t2 = {};
      Object.keys(this.config.exposeProperties).forEach((r2) => {
        const n2 = this.config.exposeProperties[r2];
        null != n2 && (t2[r2] = { value: n2(e3, this.config.matchesTypes), configurable: true, enumerable: true });
      }), Object.defineProperties(this.item, t2);
    }
  }
  canDrag() {
    return true;
  }
  beginDrag() {
    return this.item;
  }
  isDragging(e3, t2) {
    return t2 === e3.getSourceId();
  }
  endDrag() {
  }
  constructor(e3) {
    this.config = e3, this.item = {}, this.initializeExposedProperties();
  }
};
var lt = "__NATIVE_FILE__";
var ut = "__NATIVE_URL__";
var dt = "__NATIVE_TEXT__";
var ht = "__NATIVE_HTML__";
var gt = Object.freeze({ __proto__: null, FILE: lt, HTML: ht, TEXT: dt, URL: ut });
function ft(e3, t2, r2) {
  const n2 = t2.reduce((t3, r3) => t3 || e3.getData(r3), "");
  return null != n2 ? n2 : r2;
}
var pt = { [lt]: { exposeProperties: { files: (e3) => Array.prototype.slice.call(e3.files), items: (e3) => e3.items, dataTransfer: (e3) => e3 }, matchesTypes: ["Files"] }, [ht]: { exposeProperties: { html: (e3, t2) => ft(e3, t2, ""), dataTransfer: (e3) => e3 }, matchesTypes: ["Html", "text/html"] }, [ut]: { exposeProperties: { urls: (e3, t2) => ft(e3, t2, "").split("\n"), dataTransfer: (e3) => e3 }, matchesTypes: ["Url", "text/uri-list"] }, [dt]: { exposeProperties: { text: (e3, t2) => ft(e3, t2, ""), dataTransfer: (e3) => e3 }, matchesTypes: ["Text", "text/plain"] } };
function vt(e3) {
  if (!e3) return null;
  const t2 = Array.prototype.slice.call(e3.types || []);
  return Object.keys(pt).filter((e4) => {
    const r2 = pt[e4];
    return !!(null == r2 ? void 0 : r2.matchesTypes) && r2.matchesTypes.some((e5) => t2.indexOf(e5) > -1);
  })[0] || null;
}
var mt = st(() => /firefox/i.test(navigator.userAgent));
var yt = st(() => Boolean(window.safari));
var bt = class {
  interpolate(e3) {
    const { xs: t2, ys: r2, c1s: n2, c2s: o2, c3s: i2 } = this;
    let s2 = t2.length - 1;
    if (e3 === t2[s2]) return r2[s2];
    let a2, c2 = 0, l2 = i2.length - 1;
    for (; c2 <= l2; ) {
      a2 = Math.floor(0.5 * (c2 + l2));
      const n3 = t2[a2];
      if (n3 < e3) c2 = a2 + 1;
      else {
        if (!(n3 > e3)) return r2[a2];
        l2 = a2 - 1;
      }
    }
    s2 = Math.max(0, l2);
    const u2 = e3 - t2[s2], d2 = u2 * u2;
    return r2[s2] + n2[s2] * u2 + o2[s2] * d2 + i2[s2] * u2 * d2;
  }
  constructor(e3, t2) {
    const { length: r2 } = e3, n2 = [];
    for (let e4 = 0; e4 < r2; e4++) n2.push(e4);
    n2.sort((t3, r3) => e3[t3] < e3[r3] ? -1 : 1);
    const o2 = [], i2 = [];
    let s2, a2;
    for (let n3 = 0; n3 < r2 - 1; n3++) s2 = e3[n3 + 1] - e3[n3], a2 = t2[n3 + 1] - t2[n3], o2.push(s2), i2.push(a2 / s2);
    const c2 = [i2[0]];
    for (let e4 = 0; e4 < o2.length - 1; e4++) {
      const t3 = i2[e4], r3 = i2[e4 + 1];
      if (t3 * r3 <= 0) c2.push(0);
      else {
        s2 = o2[e4];
        const n3 = o2[e4 + 1], i3 = s2 + n3;
        c2.push(3 * i3 / ((i3 + n3) / t3 + (i3 + s2) / r3));
      }
    }
    c2.push(i2[i2.length - 1]);
    const l2 = [], u2 = [];
    let d2;
    for (let e4 = 0; e4 < c2.length - 1; e4++) {
      d2 = i2[e4];
      const t3 = c2[e4], r3 = 1 / o2[e4], n3 = t3 + c2[e4 + 1] - d2 - d2;
      l2.push((d2 - t3 - n3) * r3), u2.push(n3 * r3 * r3);
    }
    this.xs = e3, this.ys = t2, this.c1s = c2, this.c2s = l2, this.c3s = u2;
  }
};
var Ot = 1;
function wt(e3) {
  const t2 = e3.nodeType === Ot ? e3 : e3.parentElement;
  if (!t2) return null;
  const { top: r2, left: n2 } = t2.getBoundingClientRect();
  return { x: n2, y: r2 };
}
function St(e3) {
  return { x: e3.clientX, y: e3.clientY };
}
function Dt(e3, t2, r2, n2, o2) {
  const i2 = "IMG" === (s2 = t2).nodeName && (mt() || !(null === (a2 = document.documentElement) || void 0 === a2 ? void 0 : a2.contains(s2)));
  var s2, a2;
  const c2 = wt(i2 ? e3 : t2), l2 = { x: r2.x - c2.x, y: r2.y - c2.y }, { offsetWidth: u2, offsetHeight: d2 } = e3, { anchorX: h2, anchorY: g2 } = n2, { dragPreviewWidth: f2, dragPreviewHeight: p2 } = function(e4, t3, r3, n3) {
    let o3 = e4 ? t3.width : r3, i3 = e4 ? t3.height : n3;
    return yt() && e4 && (i3 /= window.devicePixelRatio, o3 /= window.devicePixelRatio), { dragPreviewWidth: o3, dragPreviewHeight: i3 };
  }(i2, t2, u2, d2), { offsetX: v2, offsetY: m2 } = o2, y = 0 === m2 || m2;
  return { x: 0 === v2 || v2 ? v2 : new bt([0, 0.5, 1], [l2.x, l2.x / u2 * f2, l2.x + f2 - u2]).interpolate(h2), y: y ? m2 : (() => {
    let e4 = new bt([0, 0.5, 1], [l2.y, l2.y / d2 * p2, l2.y + p2 - d2]).interpolate(g2);
    return yt() && i2 && (e4 += (window.devicePixelRatio - 1) * p2), e4;
  })() };
}
var Ct;
function Tt(e3, t2, r2) {
  return t2 in e3 ? Object.defineProperty(e3, t2, { value: r2, enumerable: true, configurable: true, writable: true }) : e3[t2] = r2, e3;
}
function Et(e3) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var r2 = null != arguments[t2] ? arguments[t2] : {}, n2 = Object.keys(r2);
    "function" == typeof Object.getOwnPropertySymbols && (n2 = n2.concat(Object.getOwnPropertySymbols(r2).filter(function(e4) {
      return Object.getOwnPropertyDescriptor(r2, e4).enumerable;
    }))), n2.forEach(function(t3) {
      Tt(e3, t3, r2[t3]);
    });
  }
  return e3;
}
var It = class {
  profile() {
    var e3, t2;
    return { sourcePreviewNodes: this.sourcePreviewNodes.size, sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size, sourceNodeOptions: this.sourceNodeOptions.size, sourceNodes: this.sourceNodes.size, dragStartSourceIds: (null === (e3 = this.dragStartSourceIds) || void 0 === e3 ? void 0 : e3.length) || 0, dropTargetIds: this.dropTargetIds.length, dragEnterTargetIds: this.dragEnterTargetIds.length, dragOverTargetIds: (null === (t2 = this.dragOverTargetIds) || void 0 === t2 ? void 0 : t2.length) || 0 };
  }
  get window() {
    return this.options.window;
  }
  get document() {
    return this.options.document;
  }
  get rootElement() {
    return this.options.rootElement;
  }
  setup() {
    const e3 = this.rootElement;
    if (void 0 !== e3) {
      if (e3.__isReactDndBackendSetUp) throw new Error("Cannot have two HTML5 backends at the same time.");
      e3.__isReactDndBackendSetUp = true, this.addEventListeners(e3);
    }
  }
  teardown() {
    const e3 = this.rootElement;
    var t2;
    void 0 !== e3 && (e3.__isReactDndBackendSetUp = false, this.removeEventListeners(this.rootElement), this.clearCurrentDragSourceNode(), this.asyncEndDragFrameId && (null === (t2 = this.window) || void 0 === t2 || t2.cancelAnimationFrame(this.asyncEndDragFrameId)));
  }
  connectDragPreview(e3, t2, r2) {
    return this.sourcePreviewNodeOptions.set(e3, r2), this.sourcePreviewNodes.set(e3, t2), () => {
      this.sourcePreviewNodes.delete(e3), this.sourcePreviewNodeOptions.delete(e3);
    };
  }
  connectDragSource(e3, t2, r2) {
    this.sourceNodes.set(e3, t2), this.sourceNodeOptions.set(e3, r2);
    const n2 = (t3) => this.handleDragStart(t3, e3), o2 = (e4) => this.handleSelectStart(e4);
    return t2.setAttribute("draggable", "true"), t2.addEventListener("dragstart", n2), t2.addEventListener("selectstart", o2), () => {
      this.sourceNodes.delete(e3), this.sourceNodeOptions.delete(e3), t2.removeEventListener("dragstart", n2), t2.removeEventListener("selectstart", o2), t2.setAttribute("draggable", "false");
    };
  }
  connectDropTarget(e3, t2) {
    const r2 = (t3) => this.handleDragEnter(t3, e3), n2 = (t3) => this.handleDragOver(t3, e3), o2 = (t3) => this.handleDrop(t3, e3);
    return t2.addEventListener("dragenter", r2), t2.addEventListener("dragover", n2), t2.addEventListener("drop", o2), () => {
      t2.removeEventListener("dragenter", r2), t2.removeEventListener("dragover", n2), t2.removeEventListener("drop", o2);
    };
  }
  addEventListeners(e3) {
    e3.addEventListener && (e3.addEventListener("dragstart", this.handleTopDragStart), e3.addEventListener("dragstart", this.handleTopDragStartCapture, true), e3.addEventListener("dragend", this.handleTopDragEndCapture, true), e3.addEventListener("dragenter", this.handleTopDragEnter), e3.addEventListener("dragenter", this.handleTopDragEnterCapture, true), e3.addEventListener("dragleave", this.handleTopDragLeaveCapture, true), e3.addEventListener("dragover", this.handleTopDragOver), e3.addEventListener("dragover", this.handleTopDragOverCapture, true), e3.addEventListener("drop", this.handleTopDrop), e3.addEventListener("drop", this.handleTopDropCapture, true));
  }
  removeEventListeners(e3) {
    e3.removeEventListener && (e3.removeEventListener("dragstart", this.handleTopDragStart), e3.removeEventListener("dragstart", this.handleTopDragStartCapture, true), e3.removeEventListener("dragend", this.handleTopDragEndCapture, true), e3.removeEventListener("dragenter", this.handleTopDragEnter), e3.removeEventListener("dragenter", this.handleTopDragEnterCapture, true), e3.removeEventListener("dragleave", this.handleTopDragLeaveCapture, true), e3.removeEventListener("dragover", this.handleTopDragOver), e3.removeEventListener("dragover", this.handleTopDragOverCapture, true), e3.removeEventListener("drop", this.handleTopDrop), e3.removeEventListener("drop", this.handleTopDropCapture, true));
  }
  getCurrentSourceNodeOptions() {
    const e3 = this.monitor.getSourceId(), t2 = this.sourceNodeOptions.get(e3);
    return Et({ dropEffect: this.altKeyPressed ? "copy" : "move" }, t2 || {});
  }
  getCurrentDropEffect() {
    return this.isDraggingNativeItem() ? "copy" : this.getCurrentSourceNodeOptions().dropEffect;
  }
  getCurrentSourcePreviewNodeOptions() {
    const e3 = this.monitor.getSourceId();
    return Et({ anchorX: 0.5, anchorY: 0.5, captureDraggingState: false }, this.sourcePreviewNodeOptions.get(e3) || {});
  }
  isDraggingNativeItem() {
    const e3 = this.monitor.getItemType();
    return Object.keys(gt).some((t2) => gt[t2] === e3);
  }
  beginDragNativeItem(e3, t2) {
    this.clearCurrentDragSourceNode(), this.currentNativeSource = function(e4, t3) {
      const r2 = pt[e4];
      if (!r2) throw new Error(`native type ${e4} has no configuration`);
      const n2 = new ct(r2);
      return n2.loadDataTransfer(t3), n2;
    }(e3, t2), this.currentNativeHandle = this.registry.addSource(e3, this.currentNativeSource), this.actions.beginDrag([this.currentNativeHandle]);
  }
  setCurrentDragSourceNode(e3) {
    this.clearCurrentDragSourceNode(), this.currentDragSourceNode = e3;
    this.mouseMoveTimeoutTimer = setTimeout(() => {
      var e4;
      return null === (e4 = this.rootElement) || void 0 === e4 ? void 0 : e4.addEventListener("mousemove", this.endDragIfSourceWasRemovedFromDOM, true);
    }, 1e3);
  }
  clearCurrentDragSourceNode() {
    if (this.currentDragSourceNode) {
      var e3;
      if (this.currentDragSourceNode = null, this.rootElement) null === (e3 = this.window) || void 0 === e3 || e3.clearTimeout(this.mouseMoveTimeoutTimer || void 0), this.rootElement.removeEventListener("mousemove", this.endDragIfSourceWasRemovedFromDOM, true);
      return this.mouseMoveTimeoutTimer = null, true;
    }
    return false;
  }
  handleDragStart(e3, t2) {
    e3.defaultPrevented || (this.dragStartSourceIds || (this.dragStartSourceIds = []), this.dragStartSourceIds.unshift(t2));
  }
  handleDragEnter(e3, t2) {
    this.dragEnterTargetIds.unshift(t2);
  }
  handleDragOver(e3, t2) {
    null === this.dragOverTargetIds && (this.dragOverTargetIds = []), this.dragOverTargetIds.unshift(t2);
  }
  handleDrop(e3, t2) {
    this.dropTargetIds.unshift(t2);
  }
  constructor(e3, t2, r2) {
    this.sourcePreviewNodes = /* @__PURE__ */ new Map(), this.sourcePreviewNodeOptions = /* @__PURE__ */ new Map(), this.sourceNodes = /* @__PURE__ */ new Map(), this.sourceNodeOptions = /* @__PURE__ */ new Map(), this.dragStartSourceIds = null, this.dropTargetIds = [], this.dragEnterTargetIds = [], this.currentNativeSource = null, this.currentNativeHandle = null, this.currentDragSourceNode = null, this.altKeyPressed = false, this.mouseMoveTimeoutTimer = null, this.asyncEndDragFrameId = null, this.dragOverTargetIds = null, this.lastClientOffset = null, this.hoverRafId = null, this.getSourceClientOffset = (e4) => {
      const t3 = this.sourceNodes.get(e4);
      return t3 && wt(t3) || null;
    }, this.endDragNativeItem = () => {
      this.isDraggingNativeItem() && (this.actions.endDrag(), this.currentNativeHandle && this.registry.removeSource(this.currentNativeHandle), this.currentNativeHandle = null, this.currentNativeSource = null);
    }, this.isNodeInDocument = (e4) => Boolean(e4 && this.document && this.document.body && this.document.body.contains(e4)), this.endDragIfSourceWasRemovedFromDOM = () => {
      const e4 = this.currentDragSourceNode;
      null == e4 || this.isNodeInDocument(e4) || (this.clearCurrentDragSourceNode() && this.monitor.isDragging() && this.actions.endDrag(), this.cancelHover());
    }, this.scheduleHover = (e4) => {
      null === this.hoverRafId && "undefined" != typeof requestAnimationFrame && (this.hoverRafId = requestAnimationFrame(() => {
        this.monitor.isDragging() && this.actions.hover(e4 || [], { clientOffset: this.lastClientOffset }), this.hoverRafId = null;
      }));
    }, this.cancelHover = () => {
      null !== this.hoverRafId && "undefined" != typeof cancelAnimationFrame && (cancelAnimationFrame(this.hoverRafId), this.hoverRafId = null);
    }, this.handleTopDragStartCapture = () => {
      this.clearCurrentDragSourceNode(), this.dragStartSourceIds = [];
    }, this.handleTopDragStart = (e4) => {
      if (e4.defaultPrevented) return;
      const { dragStartSourceIds: t3 } = this;
      this.dragStartSourceIds = null;
      const r3 = St(e4);
      this.monitor.isDragging() && (this.actions.endDrag(), this.cancelHover()), this.actions.beginDrag(t3 || [], { publishSource: false, getSourceClientOffset: this.getSourceClientOffset, clientOffset: r3 });
      const { dataTransfer: n2 } = e4, o2 = vt(n2);
      if (this.monitor.isDragging()) {
        if (n2 && "function" == typeof n2.setDragImage) {
          const e5 = this.monitor.getSourceId(), t5 = this.sourceNodes.get(e5), o3 = this.sourcePreviewNodes.get(e5) || t5;
          if (o3) {
            const { anchorX: e6, anchorY: i2, offsetX: s2, offsetY: a2 } = this.getCurrentSourcePreviewNodeOptions(), c2 = Dt(t5, o3, r3, { anchorX: e6, anchorY: i2 }, { offsetX: s2, offsetY: a2 });
            n2.setDragImage(o3, c2.x, c2.y);
          }
        }
        try {
          null == n2 || n2.setData("application/json", {});
        } catch (e5) {
        }
        this.setCurrentDragSourceNode(e4.target);
        const { captureDraggingState: t4 } = this.getCurrentSourcePreviewNodeOptions();
        t4 ? this.actions.publishDragSource() : setTimeout(() => this.actions.publishDragSource(), 0);
      } else if (o2) this.beginDragNativeItem(o2);
      else {
        if (n2 && !n2.types && (e4.target && !e4.target.hasAttribute || !e4.target.hasAttribute("draggable"))) return;
        e4.preventDefault();
      }
    }, this.handleTopDragEndCapture = () => {
      this.clearCurrentDragSourceNode() && this.monitor.isDragging() && this.actions.endDrag(), this.cancelHover();
    }, this.handleTopDragEnterCapture = (e4) => {
      var t3;
      (this.dragEnterTargetIds = [], this.isDraggingNativeItem()) && (null === (t3 = this.currentNativeSource) || void 0 === t3 || t3.loadDataTransfer(e4.dataTransfer));
      if (!this.enterLeaveCounter.enter(e4.target) || this.monitor.isDragging()) return;
      const { dataTransfer: r3 } = e4, n2 = vt(r3);
      n2 && this.beginDragNativeItem(n2, r3);
    }, this.handleTopDragEnter = (e4) => {
      const { dragEnterTargetIds: t3 } = this;
      if (this.dragEnterTargetIds = [], !this.monitor.isDragging()) return;
      this.altKeyPressed = e4.altKey, t3.length > 0 && this.actions.hover(t3, { clientOffset: St(e4) });
      t3.some((e5) => this.monitor.canDropOnTarget(e5)) && (e4.preventDefault(), e4.dataTransfer && (e4.dataTransfer.dropEffect = this.getCurrentDropEffect()));
    }, this.handleTopDragOverCapture = (e4) => {
      var t3;
      (this.dragOverTargetIds = [], this.isDraggingNativeItem()) && (null === (t3 = this.currentNativeSource) || void 0 === t3 || t3.loadDataTransfer(e4.dataTransfer));
    }, this.handleTopDragOver = (e4) => {
      const { dragOverTargetIds: t3 } = this;
      if (this.dragOverTargetIds = [], !this.monitor.isDragging()) return e4.preventDefault(), void (e4.dataTransfer && (e4.dataTransfer.dropEffect = "none"));
      this.altKeyPressed = e4.altKey, this.lastClientOffset = St(e4), this.scheduleHover(t3);
      (t3 || []).some((e5) => this.monitor.canDropOnTarget(e5)) ? (e4.preventDefault(), e4.dataTransfer && (e4.dataTransfer.dropEffect = this.getCurrentDropEffect())) : this.isDraggingNativeItem() ? e4.preventDefault() : (e4.preventDefault(), e4.dataTransfer && (e4.dataTransfer.dropEffect = "none"));
    }, this.handleTopDragLeaveCapture = (e4) => {
      this.isDraggingNativeItem() && e4.preventDefault();
      this.enterLeaveCounter.leave(e4.target) && (this.isDraggingNativeItem() && setTimeout(() => this.endDragNativeItem(), 0), this.cancelHover());
    }, this.handleTopDropCapture = (e4) => {
      var t3;
      (this.dropTargetIds = [], this.isDraggingNativeItem()) ? (e4.preventDefault(), null === (t3 = this.currentNativeSource) || void 0 === t3 || t3.loadDataTransfer(e4.dataTransfer)) : vt(e4.dataTransfer) && e4.preventDefault();
      this.enterLeaveCounter.reset();
    }, this.handleTopDrop = (e4) => {
      const { dropTargetIds: t3 } = this;
      this.dropTargetIds = [], this.actions.hover(t3, { clientOffset: St(e4) }), this.actions.drop({ dropEffect: this.getCurrentDropEffect() }), this.isDraggingNativeItem() ? this.endDragNativeItem() : this.monitor.isDragging() && this.actions.endDrag(), this.cancelHover();
    }, this.handleSelectStart = (e4) => {
      const t3 = e4.target;
      "function" == typeof t3.dragDrop && ("INPUT" === t3.tagName || "SELECT" === t3.tagName || "TEXTAREA" === t3.tagName || t3.isContentEditable || (e4.preventDefault(), t3.dragDrop()));
    }, this.options = new class {
      get window() {
        return this.globalContext ? this.globalContext : "undefined" != typeof window ? window : void 0;
      }
      get document() {
        var e4;
        return (null === (e4 = this.globalContext) || void 0 === e4 ? void 0 : e4.document) ? this.globalContext.document : this.window ? this.window.document : void 0;
      }
      get rootElement() {
        var e4;
        return (null === (e4 = this.optionsArgs) || void 0 === e4 ? void 0 : e4.rootElement) || this.window;
      }
      constructor(e4, t3) {
        this.ownerDocument = null, this.globalContext = e4, this.optionsArgs = t3;
      }
    }(t2, r2), this.actions = e3.getActions(), this.monitor = e3.getMonitor(), this.registry = e3.getRegistry(), this.enterLeaveCounter = new at(this.isNodeInDocument);
  }
};
var kt = function(e3, t2, r2) {
  return new It(e3, t2, r2);
};
var Lt;
!function(e3) {
  e3.mouse = "mouse", e3.touch = "touch", e3.keyboard = "keyboard";
}(Lt || (Lt = {}));
var Pt = class {
  get delay() {
    var e3;
    return null !== (e3 = this.args.delay) && void 0 !== e3 ? e3 : 0;
  }
  get scrollAngleRanges() {
    return this.args.scrollAngleRanges;
  }
  get getDropTargetElementsAtPoint() {
    return this.args.getDropTargetElementsAtPoint;
  }
  get ignoreContextMenu() {
    var e3;
    return null !== (e3 = this.args.ignoreContextMenu) && void 0 !== e3 && e3;
  }
  get enableHoverOutsideTarget() {
    var e3;
    return null !== (e3 = this.args.enableHoverOutsideTarget) && void 0 !== e3 && e3;
  }
  get enableKeyboardEvents() {
    var e3;
    return null !== (e3 = this.args.enableKeyboardEvents) && void 0 !== e3 && e3;
  }
  get enableMouseEvents() {
    var e3;
    return null !== (e3 = this.args.enableMouseEvents) && void 0 !== e3 && e3;
  }
  get enableTouchEvents() {
    var e3;
    return null === (e3 = this.args.enableTouchEvents) || void 0 === e3 || e3;
  }
  get touchSlop() {
    return this.args.touchSlop || 0;
  }
  get delayTouchStart() {
    var e3, t2, r2, n2;
    return null !== (n2 = null !== (r2 = null === (e3 = this.args) || void 0 === e3 ? void 0 : e3.delayTouchStart) && void 0 !== r2 ? r2 : null === (t2 = this.args) || void 0 === t2 ? void 0 : t2.delay) && void 0 !== n2 ? n2 : 0;
  }
  get delayMouseStart() {
    var e3, t2, r2, n2;
    return null !== (n2 = null !== (r2 = null === (e3 = this.args) || void 0 === e3 ? void 0 : e3.delayMouseStart) && void 0 !== r2 ? r2 : null === (t2 = this.args) || void 0 === t2 ? void 0 : t2.delay) && void 0 !== n2 ? n2 : 0;
  }
  get window() {
    return this.context && this.context.window ? this.context.window : "undefined" != typeof window ? window : void 0;
  }
  get document() {
    var e3;
    return (null === (e3 = this.context) || void 0 === e3 ? void 0 : e3.document) ? this.context.document : this.window ? this.window.document : void 0;
  }
  get rootElement() {
    var e3;
    return (null === (e3 = this.args) || void 0 === e3 ? void 0 : e3.rootElement) || this.document;
  }
  constructor(e3, t2) {
    this.args = e3, this.context = t2;
  }
};
var xt = 1;
var Mt = 0;
function Nt(e3) {
  return void 0 === e3.button || e3.button === Mt;
}
function jt(e3) {
  return !!e3.targetTouches;
}
function Rt(e3, t2) {
  return jt(e3) ? function(e4, t3) {
    return 1 === e4.targetTouches.length ? Rt(e4.targetTouches[0]) : t3 && 1 === e4.touches.length && e4.touches[0].target === t3.target ? Rt(e4.touches[0]) : void 0;
  }(e3, t2) : { x: e3.clientX, y: e3.clientY };
}
var At = (() => {
  let e3 = false;
  try {
    addEventListener("test", () => {
    }, Object.defineProperty({}, "passive", { get: () => (e3 = true, true) }));
  } catch (e4) {
  }
  return e3;
})();
var qt = { [Lt.mouse]: { start: "mousedown", move: "mousemove", end: "mouseup", contextmenu: "contextmenu" }, [Lt.touch]: { start: "touchstart", move: "touchmove", end: "touchend" }, [Lt.keyboard]: { keydown: "keydown" } };
var _t = class __t {
  profile() {
    var e3;
    return { sourceNodes: this.sourceNodes.size, sourcePreviewNodes: this.sourcePreviewNodes.size, sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size, targetNodes: this.targetNodes.size, dragOverTargetIds: (null === (e3 = this.dragOverTargetIds) || void 0 === e3 ? void 0 : e3.length) || 0 };
  }
  get document() {
    return this.options.document;
  }
  setup() {
    const e3 = this.options.rootElement;
    e3 && (E(!__t.isSetUp, "Cannot have two Touch backends at the same time."), __t.isSetUp = true, this.addEventListener(e3, "start", this.getTopMoveStartHandler()), this.addEventListener(e3, "start", this.handleTopMoveStartCapture, true), this.addEventListener(e3, "move", this.handleTopMove), this.addEventListener(e3, "move", this.handleTopMoveCapture, true), this.addEventListener(e3, "end", this.handleTopMoveEndCapture, true), this.options.enableMouseEvents && !this.options.ignoreContextMenu && this.addEventListener(e3, "contextmenu", this.handleTopMoveEndCapture), this.options.enableKeyboardEvents && this.addEventListener(e3, "keydown", this.handleCancelOnEscape, true));
  }
  teardown() {
    const e3 = this.options.rootElement;
    e3 && (__t.isSetUp = false, this._mouseClientOffset = {}, this.removeEventListener(e3, "start", this.handleTopMoveStartCapture, true), this.removeEventListener(e3, "start", this.handleTopMoveStart), this.removeEventListener(e3, "move", this.handleTopMoveCapture, true), this.removeEventListener(e3, "move", this.handleTopMove), this.removeEventListener(e3, "end", this.handleTopMoveEndCapture, true), this.options.enableMouseEvents && !this.options.ignoreContextMenu && this.removeEventListener(e3, "contextmenu", this.handleTopMoveEndCapture), this.options.enableKeyboardEvents && this.removeEventListener(e3, "keydown", this.handleCancelOnEscape, true), this.uninstallSourceNodeRemovalObserver());
  }
  addEventListener(e3, t2, r2, n2 = false) {
    const o2 = At ? { capture: n2, passive: false } : n2;
    this.listenerTypes.forEach(function(n3) {
      const i2 = qt[n3][t2];
      i2 && e3.addEventListener(i2, r2, o2);
    });
  }
  removeEventListener(e3, t2, r2, n2 = false) {
    const o2 = At ? { capture: n2, passive: false } : n2;
    this.listenerTypes.forEach(function(n3) {
      const i2 = qt[n3][t2];
      i2 && e3.removeEventListener(i2, r2, o2);
    });
  }
  connectDragSource(e3, t2) {
    const r2 = this.handleMoveStart.bind(this, e3);
    return this.sourceNodes.set(e3, t2), this.addEventListener(t2, "start", r2), () => {
      this.sourceNodes.delete(e3), this.removeEventListener(t2, "start", r2);
    };
  }
  connectDragPreview(e3, t2, r2) {
    return this.sourcePreviewNodeOptions.set(e3, r2), this.sourcePreviewNodes.set(e3, t2), () => {
      this.sourcePreviewNodes.delete(e3), this.sourcePreviewNodeOptions.delete(e3);
    };
  }
  connectDropTarget(e3, t2) {
    const r2 = this.options.rootElement;
    if (!this.document || !r2) return () => {
    };
    const n2 = (n3) => {
      if (!this.document || !r2 || !this.monitor.isDragging()) return;
      let o2;
      switch (n3.type) {
        case qt.mouse.move:
          o2 = { x: n3.clientX, y: n3.clientY };
          break;
        case qt.touch.move:
          var i2, s2;
          o2 = { x: (null === (i2 = n3.touches[0]) || void 0 === i2 ? void 0 : i2.clientX) || 0, y: (null === (s2 = n3.touches[0]) || void 0 === s2 ? void 0 : s2.clientY) || 0 };
      }
      const a2 = null != o2 ? this.document.elementFromPoint(o2.x, o2.y) : void 0, c2 = a2 && t2.contains(a2);
      return a2 === t2 || c2 ? this.handleMove(n3, e3) : void 0;
    };
    return this.addEventListener(this.document.body, "move", n2), this.targetNodes.set(e3, t2), () => {
      this.document && (this.targetNodes.delete(e3), this.removeEventListener(this.document.body, "move", n2));
    };
  }
  getTopMoveStartHandler() {
    return this.options.delayTouchStart || this.options.delayMouseStart ? this.handleTopMoveStartDelay : this.handleTopMoveStart;
  }
  installSourceNodeRemovalObserver(e3) {
    this.uninstallSourceNodeRemovalObserver(), this.draggedSourceNode = e3, this.draggedSourceNodeRemovalObserver = new MutationObserver(() => {
      e3 && !e3.parentElement && (this.resurrectSourceNode(), this.uninstallSourceNodeRemovalObserver());
    }), e3 && e3.parentElement && this.draggedSourceNodeRemovalObserver.observe(e3.parentElement, { childList: true });
  }
  resurrectSourceNode() {
    this.document && this.draggedSourceNode && (this.draggedSourceNode.style.display = "none", this.draggedSourceNode.removeAttribute("data-reactid"), this.document.body.appendChild(this.draggedSourceNode));
  }
  uninstallSourceNodeRemovalObserver() {
    this.draggedSourceNodeRemovalObserver && this.draggedSourceNodeRemovalObserver.disconnect(), this.draggedSourceNodeRemovalObserver = void 0, this.draggedSourceNode = void 0;
  }
  constructor(e3, t2, r2) {
    this.getSourceClientOffset = (e4) => {
      const t3 = this.sourceNodes.get(e4);
      return t3 && function(e5) {
        const t4 = 1 === e5.nodeType ? e5 : e5.parentElement;
        if (!t4) return;
        const { top: r3, left: n2 } = t4.getBoundingClientRect();
        return { x: n2, y: r3 };
      }(t3);
    }, this.handleTopMoveStartCapture = (e4) => {
      Nt(e4) && (this.moveStartSourceIds = []);
    }, this.handleMoveStart = (e4) => {
      Array.isArray(this.moveStartSourceIds) && this.moveStartSourceIds.unshift(e4);
    }, this.handleTopMoveStart = (e4) => {
      if (!Nt(e4)) return;
      const t3 = Rt(e4);
      t3 && (jt(e4) && (this.lastTargetTouchFallback = e4.targetTouches[0]), this._mouseClientOffset = t3), this.waitingForDelay = false;
    }, this.handleTopMoveStartDelay = (e4) => {
      if (!Nt(e4)) return;
      const t3 = e4.type === qt.touch.start ? this.options.delayTouchStart : this.options.delayMouseStart;
      this.timeout = setTimeout(this.handleTopMoveStart.bind(this, e4), t3), this.waitingForDelay = true;
    }, this.handleTopMoveCapture = () => {
      this.dragOverTargetIds = [];
    }, this.handleMove = (e4, t3) => {
      this.dragOverTargetIds && this.dragOverTargetIds.unshift(t3);
    }, this.handleTopMove = (e4) => {
      if (this.timeout && clearTimeout(this.timeout), !this.document || this.waitingForDelay) return;
      const { moveStartSourceIds: t3, dragOverTargetIds: r3 } = this, n2 = this.options.enableHoverOutsideTarget, o2 = Rt(e4, this.lastTargetTouchFallback);
      if (!o2) return;
      if (this._isScrolling || !this.monitor.isDragging() && function(e5, t4, r4, n3, o3) {
        if (!o3) return false;
        const i3 = 180 * Math.atan2(n3 - t4, r4 - e5) / Math.PI + 180;
        for (let e6 = 0; e6 < o3.length; ++e6) {
          const t5 = o3[e6];
          if (t5 && (null == t5.start || i3 >= t5.start) && (null == t5.end || i3 <= t5.end)) return true;
        }
        return false;
      }(this._mouseClientOffset.x || 0, this._mouseClientOffset.y || 0, o2.x, o2.y, this.options.scrollAngleRanges)) return void (this._isScrolling = true);
      var i2, s2, a2, c2;
      if (!this.monitor.isDragging() && this._mouseClientOffset.hasOwnProperty("x") && t3 && (i2 = this._mouseClientOffset.x || 0, s2 = this._mouseClientOffset.y || 0, a2 = o2.x, c2 = o2.y, Math.sqrt(Math.pow(Math.abs(a2 - i2), 2) + Math.pow(Math.abs(c2 - s2), 2)) > (this.options.touchSlop ? this.options.touchSlop : 0)) && (this.moveStartSourceIds = void 0, this.actions.beginDrag(t3, { clientOffset: this._mouseClientOffset, getSourceClientOffset: this.getSourceClientOffset, publishSource: false })), !this.monitor.isDragging()) return;
      const l2 = this.sourceNodes.get(this.monitor.getSourceId());
      this.installSourceNodeRemovalObserver(l2), this.actions.publishDragSource(), e4.cancelable && e4.preventDefault();
      const u2 = (r3 || []).map((e5) => this.targetNodes.get(e5)).filter((e5) => !!e5), d2 = this.options.getDropTargetElementsAtPoint ? this.options.getDropTargetElementsAtPoint(o2.x, o2.y, u2) : this.document.elementsFromPoint(o2.x, o2.y), h2 = [];
      for (const e5 in d2) {
        if (!d2.hasOwnProperty(e5)) continue;
        let t4 = d2[e5];
        for (null != t4 && h2.push(t4); t4; ) t4 = t4.parentElement, t4 && -1 === h2.indexOf(t4) && h2.push(t4);
      }
      const g2 = h2.filter((e5) => u2.indexOf(e5) > -1).map((e5) => this._getDropTargetId(e5)).filter((e5) => !!e5).filter((e5, t4, r4) => r4.indexOf(e5) === t4);
      if (n2) for (const e5 in this.targetNodes) {
        const t4 = this.targetNodes.get(e5);
        if (l2 && t4 && t4.contains(l2) && -1 === g2.indexOf(e5)) {
          g2.unshift(e5);
          break;
        }
      }
      g2.reverse(), this.actions.hover(g2, { clientOffset: o2 });
    }, this._getDropTargetId = (e4) => {
      const t3 = this.targetNodes.keys();
      let r3 = t3.next();
      for (; false === r3.done; ) {
        const n2 = r3.value;
        if (e4 === this.targetNodes.get(n2)) return n2;
        r3 = t3.next();
      }
    }, this.handleTopMoveEndCapture = (e4) => {
      this._isScrolling = false, this.lastTargetTouchFallback = void 0, function(e5) {
        return void 0 === e5.buttons || 0 == (e5.buttons & xt);
      }(e4) && (this.monitor.isDragging() && !this.monitor.didDrop() ? (e4.cancelable && e4.preventDefault(), this._mouseClientOffset = {}, this.uninstallSourceNodeRemovalObserver(), this.actions.drop(), this.actions.endDrag()) : this.moveStartSourceIds = void 0);
    }, this.handleCancelOnEscape = (e4) => {
      "Escape" === e4.key && this.monitor.isDragging() && (this._mouseClientOffset = {}, this.uninstallSourceNodeRemovalObserver(), this.actions.endDrag());
    }, this.options = new Pt(r2, t2), this.actions = e3.getActions(), this.monitor = e3.getMonitor(), this.sourceNodes = /* @__PURE__ */ new Map(), this.sourcePreviewNodes = /* @__PURE__ */ new Map(), this.sourcePreviewNodeOptions = /* @__PURE__ */ new Map(), this.targetNodes = /* @__PURE__ */ new Map(), this.listenerTypes = [], this._mouseClientOffset = {}, this._isScrolling = false, this.options.enableMouseEvents && this.listenerTypes.push(Lt.mouse), this.options.enableTouchEvents && this.listenerTypes.push(Lt.touch), this.options.enableKeyboardEvents && this.listenerTypes.push(Lt.keyboard);
  }
};
var Ht = function(e3, t2 = {}, r2 = {}) {
  return new _t(e3, t2, r2);
};
var zt = "abcdefgh".split("");
var Bt = { a8: "bR", b8: "bN", c8: "bB", d8: "bQ", e8: "bK", f8: "bB", g8: "bN", h8: "bR", a7: "bP", b7: "bP", c7: "bP", d7: "bP", e7: "bP", f7: "bP", g7: "bP", h7: "bP", a2: "wP", b2: "wP", c2: "wP", d2: "wP", e2: "wP", f2: "wP", g2: "wP", h2: "wP", a1: "wR", b1: "wN", c1: "wB", d1: "wQ", e1: "wK", f1: "wB", g1: "wN", h1: "wR" };
var Wt = { a: 0, b: 1, c: 2, d: 3, e: 4, f: 5, g: 6, h: 7 };
var Ut = { a: 7, b: 6, c: 5, d: 4, e: 3, f: 2, g: 1, h: 0 };
var Ft = [7, 6, 5, 4, 3, 2, 1, 0];
var $t = [0, 1, 2, 3, 4, 5, 6, 7];
var Vt = { wP: (0, import_jsx_runtime.jsx)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: (0, import_jsx_runtime.jsx)("path", { d: "m 22.5,9 c -2.21,0 -4,1.79 -4,4 0,0.89 0.29,1.71 0.78,2.38 C 17.33,16.5 16,18.59 16,21 c 0,2.03 0.94,3.84 2.41,5.03 C 15.41,27.09 11,31.58 11,39.5 H 34 C 34,31.58 29.59,27.09 26.59,26.03 28.06,24.84 29,23.03 29,21 29,18.59 27.67,16.5 25.72,15.38 26.21,14.71 26.5,13.89 26.5,13 c 0,-2.21 -1.79,-4 -4,-4 z", style: { opacity: "1", fill: "#ffffff", fillOpacity: "1", fillRule: "nonzero", stroke: "#000000", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "miter", strokeMiterlimit: "4", strokeDasharray: "none", strokeOpacity: "1" } }) })), wR: (0, import_jsx_runtime.jsx)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: (0, import_jsx_runtime.jsxs)("g", Object.assign({ style: { opacity: "1", fill: "#ffffff", fillOpacity: "1", fillRule: "evenodd", stroke: "#000000", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round", strokeMiterlimit: "4", strokeDasharray: "none", strokeOpacity: "1" } }, { children: [(0, import_jsx_runtime.jsx)("path", { d: "M 9,39 L 36,39 L 36,36 L 9,36 L 9,39 z ", style: { strokeLinecap: "butt" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 12,36 L 12,32 L 33,32 L 33,36 L 12,36 z ", style: { strokeLinecap: "butt" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 11,14 L 11,9 L 15,9 L 15,11 L 20,11 L 20,9 L 25,9 L 25,11 L 30,11 L 30,9 L 34,9 L 34,14", style: { strokeLinecap: "butt" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 34,14 L 31,17 L 14,17 L 11,14" }), (0, import_jsx_runtime.jsx)("path", { d: "M 31,17 L 31,29.5 L 14,29.5 L 14,17", style: { strokeLinecap: "butt", strokeLinejoin: "miter" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 31,29.5 L 32.5,32 L 12.5,32 L 14,29.5" }), (0, import_jsx_runtime.jsx)("path", { d: "M 11,14 L 34,14", style: { fill: "none", stroke: "#000000", strokeLinejoin: "miter" } })] })) })), wN: (0, import_jsx_runtime.jsx)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: (0, import_jsx_runtime.jsxs)("g", Object.assign({ style: { opacity: "1", fill: "none", fillOpacity: "1", fillRule: "evenodd", stroke: "#000000", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round", strokeMiterlimit: "4", strokeDasharray: "none", strokeOpacity: "1" } }, { children: [(0, import_jsx_runtime.jsx)("path", { d: "M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18", style: { fill: "#ffffff", stroke: "#000000" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10", style: { fill: "#ffffff", stroke: "#000000" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z", style: { fill: "#000000", stroke: "#000000" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 15 15.5 A 0.5 1.5 0 1 1  14,15.5 A 0.5 1.5 0 1 1  15 15.5 z", transform: "matrix(0.866,0.5,-0.5,0.866,9.693,-5.173)", style: { fill: "#000000", stroke: "#000000" } })] })) })), wB: (0, import_jsx_runtime.jsx)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: (0, import_jsx_runtime.jsxs)("g", Object.assign({ style: { opacity: "1", fill: "none", fillRule: "evenodd", fillOpacity: "1", stroke: "#000000", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round", strokeMiterlimit: "4", strokeDasharray: "none", strokeOpacity: "1" } }, { children: [(0, import_jsx_runtime.jsxs)("g", Object.assign({ style: { fill: "#ffffff", stroke: "#000000", strokeLinecap: "butt" } }, { children: [(0, import_jsx_runtime.jsx)("path", { d: "M 9,36 C 12.39,35.03 19.11,36.43 22.5,34 C 25.89,36.43 32.61,35.03 36,36 C 36,36 37.65,36.54 39,38 C 38.32,38.97 37.35,38.99 36,38.5 C 32.61,37.53 25.89,38.96 22.5,37.5 C 19.11,38.96 12.39,37.53 9,38.5 C 7.65,38.99 6.68,38.97 6,38 C 7.35,36.54 9,36 9,36 z" }), (0, import_jsx_runtime.jsx)("path", { d: "M 15,32 C 17.5,34.5 27.5,34.5 30,32 C 30.5,30.5 30,30 30,30 C 30,27.5 27.5,26 27.5,26 C 33,24.5 33.5,14.5 22.5,10.5 C 11.5,14.5 12,24.5 17.5,26 C 17.5,26 15,27.5 15,30 C 15,30 14.5,30.5 15,32 z" }), (0, import_jsx_runtime.jsx)("path", { d: "M 25 8 A 2.5 2.5 0 1 1  20,8 A 2.5 2.5 0 1 1  25 8 z" })] })), (0, import_jsx_runtime.jsx)("path", { d: "M 17.5,26 L 27.5,26 M 15,30 L 30,30 M 22.5,15.5 L 22.5,20.5 M 20,18 L 25,18", style: { fill: "none", stroke: "#000000", strokeLinejoin: "miter" } })] })) })), wQ: (0, import_jsx_runtime.jsx)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: (0, import_jsx_runtime.jsxs)("g", Object.assign({ style: { fill: "#ffffff", stroke: "#000000", strokeWidth: "1.5", strokeLinejoin: "round" } }, { children: [(0, import_jsx_runtime.jsx)("path", { d: "M 9,26 C 17.5,24.5 30,24.5 36,26 L 38.5,13.5 L 31,25 L 30.7,10.9 L 25.5,24.5 L 22.5,10 L 19.5,24.5 L 14.3,10.9 L 14,25 L 6.5,13.5 L 9,26 z" }), (0, import_jsx_runtime.jsx)("path", { d: "M 9,26 C 9,28 10.5,28 11.5,30 C 12.5,31.5 12.5,31 12,33.5 C 10.5,34.5 11,36 11,36 C 9.5,37.5 11,38.5 11,38.5 C 17.5,39.5 27.5,39.5 34,38.5 C 34,38.5 35.5,37.5 34,36 C 34,36 34.5,34.5 33,33.5 C 32.5,31 32.5,31.5 33.5,30 C 34.5,28 36,28 36,26 C 27.5,24.5 17.5,24.5 9,26 z" }), (0, import_jsx_runtime.jsx)("path", { d: "M 11.5,30 C 15,29 30,29 33.5,30", style: { fill: "none" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 12,33.5 C 18,32.5 27,32.5 33,33.5", style: { fill: "none" } }), (0, import_jsx_runtime.jsx)("circle", { cx: "6", cy: "12", r: "2" }), (0, import_jsx_runtime.jsx)("circle", { cx: "14", cy: "9", r: "2" }), (0, import_jsx_runtime.jsx)("circle", { cx: "22.5", cy: "8", r: "2" }), (0, import_jsx_runtime.jsx)("circle", { cx: "31", cy: "9", r: "2" }), (0, import_jsx_runtime.jsx)("circle", { cx: "39", cy: "12", r: "2" })] })) })), wK: (0, import_jsx_runtime.jsx)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: (0, import_jsx_runtime.jsxs)("g", Object.assign({ style: { fill: "none", fillOpacity: "1", fillRule: "evenodd", stroke: "#000000", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round", strokeMiterlimit: "4", strokeDasharray: "none", strokeOpacity: "1" } }, { children: [(0, import_jsx_runtime.jsx)("path", { d: "M 22.5,11.63 L 22.5,6", style: { fill: "none", stroke: "#000000", strokeLinejoin: "miter" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 20,8 L 25,8", style: { fill: "none", stroke: "#000000", strokeLinejoin: "miter" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 22.5,25 C 22.5,25 27,17.5 25.5,14.5 C 25.5,14.5 24.5,12 22.5,12 C 20.5,12 19.5,14.5 19.5,14.5 C 18,17.5 22.5,25 22.5,25", style: { fill: "#ffffff", stroke: "#000000", strokeLinecap: "butt", strokeLinejoin: "miter" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 12.5,37 C 18,40.5 27,40.5 32.5,37 L 32.5,30 C 32.5,30 41.5,25.5 38.5,19.5 C 34.5,13 25,16 22.5,23.5 L 22.5,27 L 22.5,23.5 C 20,16 10.5,13 6.5,19.5 C 3.5,25.5 12.5,30 12.5,30 L 12.5,37", style: { fill: "#ffffff", stroke: "#000000" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 12.5,30 C 18,27 27,27 32.5,30", style: { fill: "none", stroke: "#000000" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 12.5,33.5 C 18,30.5 27,30.5 32.5,33.5", style: { fill: "none", stroke: "#000000" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 12.5,37 C 18,34 27,34 32.5,37", style: { fill: "none", stroke: "#000000" } })] })) })), bP: (0, import_jsx_runtime.jsx)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: (0, import_jsx_runtime.jsx)("path", { d: "m 22.5,9 c -2.21,0 -4,1.79 -4,4 0,0.89 0.29,1.71 0.78,2.38 C 17.33,16.5 16,18.59 16,21 c 0,2.03 0.94,3.84 2.41,5.03 C 15.41,27.09 11,31.58 11,39.5 H 34 C 34,31.58 29.59,27.09 26.59,26.03 28.06,24.84 29,23.03 29,21 29,18.59 27.67,16.5 25.72,15.38 26.21,14.71 26.5,13.89 26.5,13 c 0,-2.21 -1.79,-4 -4,-4 z", style: { opacity: "1", fill: "#000000", fillOpacity: "1", fillRule: "nonzero", stroke: "#000000", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "miter", strokeMiterlimit: "4", strokeDasharray: "none", strokeOpacity: "1" } }) })), bR: (0, import_jsx_runtime.jsx)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: (0, import_jsx_runtime.jsxs)("g", Object.assign({ style: { opacity: "1", fill: "#000000", fillOpacity: "1", fillRule: "evenodd", stroke: "#000000", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round", strokeMiterlimit: "4", strokeDasharray: "none", strokeOpacity: "1" } }, { children: [(0, import_jsx_runtime.jsx)("path", { d: "M 9,39 L 36,39 L 36,36 L 9,36 L 9,39 z ", style: { strokeLinecap: "butt" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 12.5,32 L 14,29.5 L 31,29.5 L 32.5,32 L 12.5,32 z ", style: { strokeLinecap: "butt" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 12,36 L 12,32 L 33,32 L 33,36 L 12,36 z ", style: { strokeLinecap: "butt" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 14,29.5 L 14,16.5 L 31,16.5 L 31,29.5 L 14,29.5 z ", style: { strokeLinecap: "butt", strokeLinejoin: "miter" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 14,16.5 L 11,14 L 34,14 L 31,16.5 L 14,16.5 z ", style: { strokeLinecap: "butt" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 11,14 L 11,9 L 15,9 L 15,11 L 20,11 L 20,9 L 25,9 L 25,11 L 30,11 L 30,9 L 34,9 L 34,14 L 11,14 z ", style: { strokeLinecap: "butt" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 12,35.5 L 33,35.5 L 33,35.5", style: { fill: "none", stroke: "#ffffff", strokeWidth: "1", strokeLinejoin: "miter" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 13,31.5 L 32,31.5", style: { fill: "none", stroke: "#ffffff", strokeWidth: "1", strokeLinejoin: "miter" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 14,29.5 L 31,29.5", style: { fill: "none", stroke: "#ffffff", strokeWidth: "1", strokeLinejoin: "miter" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 14,16.5 L 31,16.5", style: { fill: "none", stroke: "#ffffff", strokeWidth: "1", strokeLinejoin: "miter" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 11,14 L 34,14", style: { fill: "none", stroke: "#ffffff", strokeWidth: "1", strokeLinejoin: "miter" } })] })) })), bN: (0, import_jsx_runtime.jsx)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: (0, import_jsx_runtime.jsxs)("g", Object.assign({ style: { opacity: "1", fill: "none", fillOpacity: "1", fillRule: "evenodd", stroke: "#000000", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round", strokeMiterlimit: "4", strokeDasharray: "none", strokeOpacity: "1" } }, { children: [(0, import_jsx_runtime.jsx)("path", { d: "M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18", style: { fill: "#000000", stroke: "#000000" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10", style: { fill: "#000000", stroke: "#000000" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z", style: { fill: "#ffffff", stroke: "#ffffff" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 15 15.5 A 0.5 1.5 0 1 1  14,15.5 A 0.5 1.5 0 1 1  15 15.5 z", transform: "matrix(0.866,0.5,-0.5,0.866,9.693,-5.173)", style: { fill: "#ffffff", stroke: "#ffffff" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 24.55,10.4 L 24.1,11.85 L 24.6,12 C 27.75,13 30.25,14.49 32.5,18.75 C 34.75,23.01 35.75,29.06 35.25,39 L 35.2,39.5 L 37.45,39.5 L 37.5,39 C 38,28.94 36.62,22.15 34.25,17.66 C 31.88,13.17 28.46,11.02 25.06,10.5 L 24.55,10.4 z ", style: { fill: "#ffffff", stroke: "none" } })] })) })), bB: (0, import_jsx_runtime.jsx)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: (0, import_jsx_runtime.jsxs)("g", Object.assign({ style: { opacity: "1", fill: "none", fillRule: "evenodd", fillOpacity: "1", stroke: "#000000", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round", strokeMiterlimit: "4", strokeDasharray: "none", strokeOpacity: "1" } }, { children: [(0, import_jsx_runtime.jsxs)("g", Object.assign({ style: { fill: "#000000", stroke: "#000000", strokeLinecap: "butt" } }, { children: [(0, import_jsx_runtime.jsx)("path", { d: "M 9,36 C 12.39,35.03 19.11,36.43 22.5,34 C 25.89,36.43 32.61,35.03 36,36 C 36,36 37.65,36.54 39,38 C 38.32,38.97 37.35,38.99 36,38.5 C 32.61,37.53 25.89,38.96 22.5,37.5 C 19.11,38.96 12.39,37.53 9,38.5 C 7.65,38.99 6.68,38.97 6,38 C 7.35,36.54 9,36 9,36 z" }), (0, import_jsx_runtime.jsx)("path", { d: "M 15,32 C 17.5,34.5 27.5,34.5 30,32 C 30.5,30.5 30,30 30,30 C 30,27.5 27.5,26 27.5,26 C 33,24.5 33.5,14.5 22.5,10.5 C 11.5,14.5 12,24.5 17.5,26 C 17.5,26 15,27.5 15,30 C 15,30 14.5,30.5 15,32 z" }), (0, import_jsx_runtime.jsx)("path", { d: "M 25 8 A 2.5 2.5 0 1 1  20,8 A 2.5 2.5 0 1 1  25 8 z" })] })), (0, import_jsx_runtime.jsx)("path", { d: "M 17.5,26 L 27.5,26 M 15,30 L 30,30 M 22.5,15.5 L 22.5,20.5 M 20,18 L 25,18", style: { fill: "none", stroke: "#ffffff", strokeLinejoin: "miter" } })] })) })), bQ: (0, import_jsx_runtime.jsx)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: (0, import_jsx_runtime.jsxs)("g", Object.assign({ style: { fill: "#000000", stroke: "#000000", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" } }, { children: [(0, import_jsx_runtime.jsx)("path", { d: "M 9,26 C 17.5,24.5 30,24.5 36,26 L 38.5,13.5 L 31,25 L 30.7,10.9 L 25.5,24.5 L 22.5,10 L 19.5,24.5 L 14.3,10.9 L 14,25 L 6.5,13.5 L 9,26 z", style: { strokeLinecap: "butt", fill: "#000000" } }), (0, import_jsx_runtime.jsx)("path", { d: "m 9,26 c 0,2 1.5,2 2.5,4 1,1.5 1,1 0.5,3.5 -1.5,1 -1,2.5 -1,2.5 -1.5,1.5 0,2.5 0,2.5 6.5,1 16.5,1 23,0 0,0 1.5,-1 0,-2.5 0,0 0.5,-1.5 -1,-2.5 -0.5,-2.5 -0.5,-2 0.5,-3.5 1,-2 2.5,-2 2.5,-4 -8.5,-1.5 -18.5,-1.5 -27,0 z" }), (0, import_jsx_runtime.jsx)("path", { d: "M 11.5,30 C 15,29 30,29 33.5,30" }), (0, import_jsx_runtime.jsx)("path", { d: "m 12,33.5 c 6,-1 15,-1 21,0" }), (0, import_jsx_runtime.jsx)("circle", { cx: "6", cy: "12", r: "2" }), (0, import_jsx_runtime.jsx)("circle", { cx: "14", cy: "9", r: "2" }), (0, import_jsx_runtime.jsx)("circle", { cx: "22.5", cy: "8", r: "2" }), (0, import_jsx_runtime.jsx)("circle", { cx: "31", cy: "9", r: "2" }), (0, import_jsx_runtime.jsx)("circle", { cx: "39", cy: "12", r: "2" }), (0, import_jsx_runtime.jsx)("path", { d: "M 11,38.5 A 35,35 1 0 0 34,38.5", style: { fill: "none", stroke: "#000000", strokeLinecap: "butt" } }), (0, import_jsx_runtime.jsxs)("g", Object.assign({ style: { fill: "none", stroke: "#ffffff" } }, { children: [(0, import_jsx_runtime.jsx)("path", { d: "M 11,29 A 35,35 1 0 1 34,29" }), (0, import_jsx_runtime.jsx)("path", { d: "M 12.5,31.5 L 32.5,31.5" }), (0, import_jsx_runtime.jsx)("path", { d: "M 11.5,34.5 A 35,35 1 0 0 33.5,34.5" }), (0, import_jsx_runtime.jsx)("path", { d: "M 10.5,37.5 A 35,35 1 0 0 34.5,37.5" })] }))] })) })), bK: (0, import_jsx_runtime.jsx)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: (0, import_jsx_runtime.jsxs)("g", Object.assign({ style: { fill: "none", fillOpacity: "1", fillRule: "evenodd", stroke: "#000000", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round", strokeMiterlimit: "4", strokeDasharray: "none", strokeOpacity: "1" } }, { children: [(0, import_jsx_runtime.jsx)("path", { d: "M 22.5,11.63 L 22.5,6", style: { fill: "none", stroke: "#000000", strokeLinejoin: "miter" }, id: "path6570" }), (0, import_jsx_runtime.jsx)("path", { d: "M 22.5,25 C 22.5,25 27,17.5 25.5,14.5 C 25.5,14.5 24.5,12 22.5,12 C 20.5,12 19.5,14.5 19.5,14.5 C 18,17.5 22.5,25 22.5,25", style: { fill: "#000000", fillOpacity: "1", strokeLinecap: "butt", strokeLinejoin: "miter" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 12.5,37 C 18,40.5 27,40.5 32.5,37 L 32.5,30 C 32.5,30 41.5,25.5 38.5,19.5 C 34.5,13 25,16 22.5,23.5 L 22.5,27 L 22.5,23.5 C 20,16 10.5,13 6.5,19.5 C 3.5,25.5 12.5,30 12.5,30 L 12.5,37", style: { fill: "#000000", stroke: "#000000" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 20,8 L 25,8", style: { fill: "none", stroke: "#000000", strokeLinejoin: "miter" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 32,29.5 C 32,29.5 40.5,25.5 38.03,19.85 C 34.15,14 25,18 22.5,24.5 L 22.5,26.6 L 22.5,24.5 C 20,18 10.85,14 6.97,19.85 C 4.5,25.5 13,29.5 13,29.5", style: { fill: "none", stroke: "#ffffff" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 12.5,30 C 18,27 27,27 32.5,30 M 12.5,33.5 C 18,30.5 27,30.5 32.5,33.5 M 12.5,37 C 18,34 27,34 32.5,37", style: { fill: "none", stroke: "#ffffff" } })] })) })) };
function Yt(e3, t2, r2) {
  const n2 = t2 / 8, o2 = "white" === e3 ? Ft : $t;
  return { x: ("white" === e3 ? Wt : Ut)[r2[0]] * n2 + n2 / 2, y: o2[parseInt(r2[1], 10) - 1] * n2 + n2 / 2 };
}
function Kt(e3) {
  let t2 = false;
  return Object.keys(Bt).forEach((r2) => {
    e3[r2] !== Bt[r2] && (t2 = true);
  }), Object.keys(e3).forEach((r2) => {
    Bt[r2] !== e3[r2] && (t2 = true);
  }), t2;
}
function Xt(e3) {
  return "start" === e3 ? Bt : "string" == typeof e3 ? function(e4) {
    if (!function(e5) {
      e5 = e5.replace(/ .+$/, ""), e5 = function(e6) {
        return e6.replace(/8/g, "11111111").replace(/7/g, "1111111").replace(/6/g, "111111").replace(/5/g, "11111").replace(/4/g, "1111").replace(/3/g, "111").replace(/2/g, "11");
      }(e5);
      const t3 = e5.split("/");
      if (8 !== t3.length) return false;
      for (let e6 = 0; e6 < 8; e6++) if (8 !== t3[e6].length || -1 !== t3[e6].search(/[^kqrnbpKQRNBP1]/)) return false;
      return true;
    }(e4)) return {};
    const t2 = (e4 = e4.replace(/ .+$/, "")).split("/"), r2 = {};
    let n2 = 8;
    for (let e5 = 0; e5 < 8; e5++) {
      const o2 = t2[e5].split("");
      let i2 = 0;
      for (let e6 = 0; e6 < o2.length; e6++) if (-1 !== o2[e6].search(/[1-8]/)) {
        i2 += parseInt(o2[e6], 10);
      } else {
        r2[zt[i2] + n2] = Gt(o2[e6]), i2 += 1;
      }
      n2 -= 1;
    }
    return r2;
  }(e3) : e3;
}
function Gt(e3) {
  return e3.toLowerCase() === e3 ? "b" + e3.toUpperCase() : "w" + e3.toUpperCase();
}
var Qt = (0, import_react.createContext)({});
var Jt = () => (0, import_react.useContext)(Qt);
var Zt = (0, import_react.forwardRef)(({ allowDragOutsideBoard: t2 = true, animationDuration: r2 = 300, areArrowsAllowed: n2 = true, arePiecesDraggable: o2 = true, arePremovesAllowed: s2 = false, autoPromoteToQueen: c2 = false, boardOrientation: l2 = "white", boardWidth: u2, children: d2, clearPremovesOnRightClick: h2 = true, customArrows: g2, customArrowColor: v2 = "rgb(255,170,0)", customBoardStyle: m2, customDarkSquareStyle: y = { backgroundColor: "#B58863" }, customDropSquareStyle: b2 = { boxShadow: "inset 0 0 1px 6px rgba(255,255,255,0.75)" }, customLightSquareStyle: O2 = { backgroundColor: "#F0D9B5" }, customPieces: w2, customPremoveDarkSquareStyle: S2 = { backgroundColor: "#A42323" }, customPremoveLightSquareStyle: D2 = { backgroundColor: "#BD2828" }, customSquare: C2 = "div", customSquareStyles: T2, dropOffBoardAction: E2 = "snapback", id: I2 = 0, isDraggablePiece: k2 = () => true, getPositionObject: L2 = () => {
}, onArrowsChange: P2 = () => {
}, onDragOverSquare: x2 = () => {
}, onMouseOutSquare: M2 = () => {
}, onMouseOverSquare: N2 = () => {
}, onPieceClick: j2 = () => {
}, onPieceDragBegin: R2 = () => {
}, onPieceDragEnd: A2 = () => {
}, onPieceDrop: q2 = () => true, onPromotionCheck: _2 = (e3, t3, r3) => ("wP" === r3 && "7" === e3[1] && "8" === t3[1] || "bP" === r3 && "2" === e3[1] && "1" === t3[1]) && Math.abs(e3.charCodeAt(0) - t3.charCodeAt(0)) <= 1, onPromotionPieceSelect: H2, onSquareClick: z2 = () => {
}, onSquareRightClick: B2 = () => {
}, position: W2 = "start", promotionDialogVariant: U2 = "default", promotionToSquare: F2 = null, showBoardNotation: $2 = true, showPromotionDialog: V2 = false, snapToCursor: Y2 = true }, K2) => {
  const [X2, G2] = (0, import_react.useState)(Xt(W2)), [Q2, J2] = (0, import_react.useState)({ removed: {}, added: {} }), [Z2, ee2] = (0, import_react.useState)(void 0), [te2, re2] = (0, import_react.useState)(V2 && !c2), [ne2, oe2] = (0, import_react.useState)(null), [ie2, se2] = (0, import_react.useState)(F2), [ae2, ce2] = (0, import_react.useState)([]), le2 = (0, import_react.useRef)(ae2), [ue2, de2] = (0, import_react.useState)(), [he2, ge2] = (0, import_react.useState)(Object.assign(Object.assign({}, Vt), w2)), [fe2, pe2] = (0, import_react.useState)(false), [ve2, me2] = (0, import_react.useState)(), [ye2, be2] = (0, import_react.useState)(false);
  (0, import_react.useImperativeHandle)(K2, () => ({ clearPremoves(e3 = true) {
    Ee2(e3);
  } })), (0, import_react.useEffect)(() => {
    ge2(Object.assign(Object.assign({}, Vt), w2));
  }, [w2]), (0, import_react.useEffect)(() => {
    re2(V2), se2(F2);
  }, [F2, V2]), (0, import_react.useEffect)(() => {
    var e3, t3, n3;
    Ie2();
    const o3 = Xt(W2), i2 = function(e4, t4) {
      const r3 = { removed: {}, added: {} };
      return Object.keys(e4).forEach((n4) => {
        t4[n4] !== e4[n4] && (r3.removed[n4] = e4[n4]);
      }), Object.keys(t4).forEach((n4) => {
        e4[n4] !== t4[n4] && (r3.added[n4] = t4[n4]);
      }), r3;
    }(X2, o3), a2 = (null === (e3 = Object.keys(i2.added)) || void 0 === e3 ? void 0 : e3.length) <= 2 ? null === (n3 = null === (t3 = Object.entries(i2.added)) || void 0 === t3 ? void 0 : t3[0]) || void 0 === n3 ? void 0 : n3[1][0] : void 0;
    if (ye2) G2(o3), be2(false), s2 && Te2(a2), ve2 && clearTimeout(ve2);
    else if (fe2) G2(o3), be2(false), s2 && Te2(a2);
    else {
      Kt(o3) && void 0 !== Z2 ? ee2(a2) : Kt(o3) ? ee2(void 0) : ee2("b"), J2(i2), be2(true);
      const e4 = setTimeout(() => {
        G2(o3), be2(false), s2 && Te2(a2);
      }, r2);
      me2(e4);
    }
    return pe2(false), L2(o3), Se2(), () => {
      clearTimeout(ve2);
    };
  }, [W2]);
  const { arrows: Oe2, newArrow: we2, clearArrows: Se2, drawNewArrow: De2, onArrowDrawEnd: Ce2 } = ((e3, t3 = true, r3, n3) => {
    const [o3, s3] = (0, import_react.useState)([]), [c3, l3] = (0, import_react.useState)([]), [u3, d3] = (0, import_react.useState)();
    (0, import_react.useEffect)(() => {
      Array.isArray(e3) && s3(null == e3 ? void 0 : e3.filter((e4) => e4[0] !== e4[1]));
    }, [e3]), (0, import_react.useEffect)(() => {
      null == r3 || r3(c3);
    }, [c3]);
    const h3 = [...c3, ...o3];
    return { arrows: h3, newArrow: u3, clearArrows: function() {
      l3([]), d3(void 0);
    }, drawNewArrow: (e4, r4) => {
      t3 && d3([e4, r4, n3]);
    }, setArrows: l3, onArrowDrawEnd: (e4, r4) => {
      if (e4 === r4 || !t3) return;
      let o4;
      const i2 = [e4, r4, n3];
      o4 = h3.every(([t4, n4]) => !(t4 === e4 && n4 === r4)) ? [...c3, i2] : c3.filter(([t4, n4]) => !(t4 === e4 && n4 === r4)), d3(void 0), l3(o4);
    } };
  })(g2, n2, P2, v2);
  function Te2(e3) {
    if (0 === le2.current.length) return;
    const t3 = le2.current[0];
    if (void 0 !== t3.piece[0] && t3.piece[0] !== e3 && q2.length) {
      ee2(t3.piece[0]), pe2(true);
      if (q2(t3.sourceSq, t3.targetSq, t3.piece)) {
        const e4 = [...le2.current];
        e4.shift(), le2.current = e4, ce2([...e4]);
      } else Ee2();
    }
  }
  function Ee2(e3 = true) {
    e3 && ee2(void 0), le2.current = [], ce2([]);
  }
  function Ie2() {
    oe2(null), se2(null), re2(false);
  }
  const ke2 = { animationDuration: r2, arePiecesDraggable: o2, arePremovesAllowed: s2, boardOrientation: l2, boardWidth: u2, customArrowColor: v2, customBoardStyle: m2, customDarkSquareStyle: y, customDropSquareStyle: b2, customLightSquareStyle: O2, customPremoveDarkSquareStyle: S2, customPremoveLightSquareStyle: D2, customSquare: C2, customSquareStyles: T2, id: I2, isDraggablePiece: k2, onDragOverSquare: x2, onMouseOutSquare: M2, onMouseOverSquare: N2, onPieceClick: j2, onPieceDragBegin: R2, onPieceDragEnd: A2, onPieceDrop: q2, onPromotionCheck: _2, onPromotionPieceSelect: H2, onSquareClick: z2, showBoardNotation: $2, snapToCursor: Y2, promotionDialogVariant: U2, allowDragOutsideBoard: t2, arrows: Oe2, newArrow: we2, onArrowDrawEnd: Ce2, chessPieces: he2, clearArrows: Se2, drawNewArrow: De2, clearCurrentRightClickDown: function() {
    de2(void 0);
  }, currentPosition: X2, handleSetPosition: function(e3, t3, r3, n3) {
    if (e3 === t3) return;
    if (Se2(), s2 && ye2 || s2 && (Z2 === r3[0] || le2.current.filter((e4) => e4.piece[0] === r3[0]).length > 0)) {
      const n4 = [...le2.current];
      return n4.push({ sourceSq: e3, targetSq: t3, piece: r3 }), le2.current = n4, ce2([...n4]), void Ie2();
    }
    if (!s2 && ye2) return;
    const o3 = Object.assign({}, X2);
    if (pe2(!!n3), ee2(r3[0]), q2.length) {
      q2(e3, t3, r3) || Ee2();
    } else "trash" !== E2 || t3 || delete o3[e3], delete o3[e3], o3[t3] = r3, G2(o3);
    Ie2(), L2(o3);
  }, isWaitingForAnimation: ye2, lastPieceColour: Z2, onRightClickDown: function(e3) {
    de2(e3);
  }, onRightClickUp: function(e3) {
    if (ue2) {
      if (ue2 === e3) return de2(void 0), h2 && Ee2(false), void B2(e3);
    } else de2(void 0);
  }, positionDifferences: Q2, promoteFromSquare: ne2, promoteToSquare: ie2, premoves: ae2, setPromoteFromSquare: oe2, setPromoteToSquare: se2, setShowPromoteDialog: re2, showPromoteDialog: te2, autoPromoteToQueen: c2, currentRightClickDown: ue2 };
  return (0, import_jsx_runtime.jsx)(Qt.Provider, Object.assign({ value: ke2 }, { children: d2 }));
});
function er({ row: n2, col: o2 }) {
  const { boardOrientation: i2, boardWidth: s2, customDarkSquareStyle: a2, customLightSquareStyle: c2 } = Jt(), l2 = c2.backgroundColor, u2 = a2.backgroundColor, d2 = 0 === o2, h2 = 7 === n2;
  function g2() {
    return "white" === i2 ? 8 - n2 : n2 + 1;
  }
  function f2() {
    return "black" === i2 ? zt[7 - o2] : zt[o2];
  }
  return d2 && h2 ? (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("div", Object.assign({ style: Object.assign(Object.assign({ zIndex: 3, position: "absolute" }, { color: l2 }), rr(s2)) }, { children: g2() })), (0, import_jsx_runtime.jsx)("div", Object.assign({ style: Object.assign(Object.assign({ zIndex: 3, position: "absolute" }, { color: l2 }), tr(s2)) }, { children: f2() }))] }) : h2 ? (0, import_jsx_runtime.jsx)("div", Object.assign({ style: Object.assign(Object.assign({ userSelect: "none", zIndex: 3, position: "absolute" }, { color: o2 % 2 != 0 ? u2 : l2 }), tr(s2)) }, { children: f2() })) : d2 ? (0, import_jsx_runtime.jsx)("div", Object.assign({ style: Object.assign(Object.assign({ userSelect: "none", zIndex: 3, position: "absolute" }, { color: n2 % 2 == 0 ? u2 : l2 }), rr(s2)) }, { children: g2() })) : null;
}
var tr = (e3) => ({ alignSelf: "flex-end", paddingLeft: e3 / 8 - e3 / 48, fontSize: e3 / 48 });
var rr = (e3) => ({ alignSelf: "flex-start", paddingRight: e3 / 8 - e3 / 48, fontSize: e3 / 48 });
function nr({ isPremovedPiece: t2 = false, piece: r2, square: n2, squares: o2 }) {
  const { animationDuration: s2, arePiecesDraggable: c2, arePremovesAllowed: l2, boardWidth: u2, boardOrientation: d2, chessPieces: h2, currentPosition: g2, id: f2, isDraggablePiece: p2, isWaitingForAnimation: v2, onPieceClick: m2, onPieceDragBegin: y, onPieceDragEnd: b2, positionDifferences: O2, premoves: w2, onPromotionCheck: S2 } = Jt(), [D2, C2] = (0, import_react.useState)({ opacity: 1, zIndex: 5, touchAction: "none", cursor: c2 && p2({ piece: r2, sourceSquare: n2 }) ? "-webkit-grab" : "default" }), [{ canDrag: T2, isDragging: E2 }, I2, k2] = tt(() => ({ type: "piece", item: () => (y(r2, n2), { piece: r2, square: n2, id: f2 }), end: () => b2(r2, n2), collect: (e3) => ({ canDrag: p2({ piece: r2, sourceSquare: n2 }), isDragging: !!e3.isDragging() }) }), [r2, n2, g2, f2]);
  return k2((Ct || (Ct = new Image(), Ct.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="), Ct), { captureDraggingState: true }), (0, import_react.useEffect)(() => {
    C2((e3) => Object.assign(Object.assign({}, e3), { opacity: E2 ? 0 : 1 }));
  }, [E2]), (0, import_react.useEffect)(() => {
    if (!l2) return;
    let e3 = false;
    !t2 && w2.find((e4) => e4.targetSq === n2) && (e3 = true), w2.find((e4) => e4.sourceSq === n2 && e4.piece === r2) && (e3 = true), C2((t3) => Object.assign(Object.assign({}, t3), { display: e3 ? "none" : "unset" }));
  }, [g2, w2]), (0, import_react.useEffect)(() => {
    var e3;
    const r3 = null === (e3 = O2.removed) || void 0 === e3 ? void 0 : e3[n2];
    if (!O2.added || !r3) return;
    const o3 = Object.entries(O2.added).find(([e4, t3]) => t3 === r3 || S2(n2, e4, r3));
    if (v2 && r3 && o3 && !t2) {
      const e4 = n2, t3 = o3[0];
      if (e4 && t3) {
        const r4 = u2 / 8;
        C2((n3) => Object.assign(Object.assign({}, n3), { transform: `translate(${("black" === d2 ? -1 : 1) * (t3.charCodeAt(0) - e4.charCodeAt(0)) * r4}px, ${("black" === d2 ? -1 : 1) * (Number(e4[1]) - Number(t3[1])) * r4}px)`, transition: `transform ${s2}ms`, zIndex: 6 }));
      }
    }
  }, [O2]), (0, import_react.useEffect)(() => {
    const { sourceSq: e3 } = { sourceSq: o2[n2] };
    e3 && C2((e4) => Object.assign(Object.assign({}, e4), { transform: "translate(0px, 0px)", transition: "transform 0ms" }));
  }, [g2]), (0, import_react.useEffect)(() => {
    C2((e3) => Object.assign(Object.assign({}, e3), { cursor: c2 && p2({ piece: r2, sourceSquare: n2 }) ? "-webkit-grab" : "default" }));
  }, [n2, g2, c2]), (0, import_jsx_runtime.jsx)("div", Object.assign({ ref: c2 && T2 ? I2 : null, onClick: () => m2(r2), "data-piece": r2, style: D2 }, { children: "function" == typeof h2[r2] ? h2[r2]({ squareWidth: u2 / 8, isDragging: E2, square: n2 }) : (0, import_jsx_runtime.jsx)("svg", Object.assign({ viewBox: "1 1 43 43", width: u2 / 8, height: u2 / 8 }, { children: (0, import_jsx_runtime.jsx)("g", { children: h2[r2] }) })) }));
}
function or({ square: t2, squareColor: r2, setSquares: n2, squareHasPremove: o2, children: s2 }) {
  const a2 = (0, import_react.useRef)(null), { autoPromoteToQueen: c2, boardWidth: l2, boardOrientation: u2, clearArrows: d2, currentPosition: h2, currentRightClickDown: g2, customBoardStyle: p2, customDarkSquareStyle: v2, customDropSquareStyle: m2, customLightSquareStyle: y, customPremoveDarkSquareStyle: b2, customPremoveLightSquareStyle: O2, customSquare: w2, customSquareStyles: S2, drawNewArrow: D2, handleSetPosition: C2, isWaitingForAnimation: T2, lastPieceColour: E2, onArrowDrawEnd: I2, onDragOverSquare: k2, onMouseOutSquare: L2, onMouseOverSquare: P2, onPieceDrop: x2, onPromotionCheck: M2, onRightClickDown: N2, onRightClickUp: j2, onSquareClick: R2, setPromoteFromSquare: A2, setPromoteToSquare: q2, setShowPromoteDialog: _2 } = Jt(), [{ isOver: H2 }, z2] = it(() => ({ accept: "piece", drop: B2, collect: (e3) => ({ isOver: !!e3.isOver() }) }), [t2, h2, x2, T2, E2]);
  function B2(e3) {
    M2(e3.square, t2, e3.piece) ? c2 ? C2(e3.square, t2, "w" === e3.piece[0] ? "wQ" : "bQ") : (A2(e3.square), q2(t2), _2(true)) : C2(e3.square, t2, e3.piece, true);
  }
  (0, import_react.useEffect)(() => {
    if (a2.current) {
      const { x: e3, y: r3 } = a2.current.getBoundingClientRect();
      n2((n3) => Object.assign(Object.assign({}, n3), { [t2]: { x: e3, y: r3 } }));
    }
  }, [l2, u2]);
  const W2 = Object.assign(Object.assign(Object.assign(Object.assign({}, ar(t2, u2, p2)), "black" === r2 ? v2 : y), o2 && ("black" === r2 ? b2 : O2)), H2 && m2);
  return (0, import_jsx_runtime.jsx)("div", Object.assign({ ref: z2, style: W2, "data-square-color": r2, "data-square": t2, onMouseOver: (e3) => {
    2 === e3.buttons && g2 && D2(g2, t2), e3.relatedTarget && e3.currentTarget.contains(e3.relatedTarget) || P2(t2);
  }, onMouseOut: (e3) => {
    e3.relatedTarget && e3.currentTarget.contains(e3.relatedTarget) || L2(t2);
  }, onMouseDown: (e3) => {
    2 === e3.button && N2(t2);
  }, onMouseUp: (e3) => {
    2 === e3.button && (g2 && I2(g2, t2), j2(t2));
  }, onDragEnter: () => k2(t2), onClick: () => {
    R2(t2), d2();
  }, onContextMenu: (e3) => {
    e3.preventDefault();
  } }, { children: (0, import_jsx_runtime.jsx)(w2, "string" == typeof w2 ? Object.assign({ ref: a2, style: Object.assign(Object.assign(Object.assign({}, sr(l2)), ir), !o2 && (null == S2 ? void 0 : S2[t2])) }, { children: s2 }) : Object.assign({ ref: a2, square: t2, squareColor: r2, style: Object.assign(Object.assign(Object.assign({}, sr(l2)), ir), !o2 && (null == S2 ? void 0 : S2[t2])) }, { children: s2 })) }));
}
var ir = { display: "flex", justifyContent: "center" };
var sr = (e3) => ({ width: e3 / 8, height: e3 / 8 });
var ar = (e3, t2, r2) => (null == r2 ? void 0 : r2.borderRadius) ? "a1" === e3 ? "white" === t2 ? { borderBottomLeftRadius: r2.borderRadius } : { borderTopRightRadius: r2.borderRadius } : "a8" === e3 ? "white" === t2 ? { borderTopLeftRadius: r2.borderRadius } : { borderBottomRightRadius: r2.borderRadius } : "h1" === e3 ? "white" === t2 ? { borderBottomRightRadius: r2.borderRadius } : { borderTopLeftRadius: r2.borderRadius } : "h8" === e3 ? "white" === t2 ? { borderTopRightRadius: r2.borderRadius } : { borderBottomLeftRadius: r2.borderRadius } : {} : {};
function cr() {
  const [r2, n2] = (0, import_react.useState)({}), { boardOrientation: o2, boardWidth: i2, currentPosition: s2, id: c2, premoves: l2, showBoardNotation: u2 } = Jt();
  return (0, import_jsx_runtime.jsx)("div", Object.assign({ "data-boardid": c2 }, { children: [...Array(8)].map((a2, c3) => (0, import_jsx_runtime.jsx)("div", Object.assign({ style: { display: "flex", flexWrap: "nowrap", width: i2 } }, { children: [...Array(8)].map((i3, a3) => {
    const d2 = "black" === o2 ? zt[7 - a3] + (c3 + 1) : zt[a3] + (8 - c3), h2 = a3 % 2 == c3 % 2 ? "white" : "black", g2 = l2.find((e3) => e3.sourceSq === d2 || e3.targetSq === d2), f2 = l2.find((e3) => e3.targetSq === d2);
    return (0, import_jsx_runtime.jsxs)(or, Object.assign({ square: d2, squareColor: h2, setSquares: n2, squareHasPremove: !!g2 }, { children: [s2[d2] && (0, import_jsx_runtime.jsx)(nr, { piece: s2[d2], square: d2, squares: r2 }), f2 && (0, import_jsx_runtime.jsx)(nr, { isPremovedPiece: true, piece: f2.piece, square: d2, squares: r2 }), u2 && (0, import_jsx_runtime.jsx)(er, { row: c3, col: a3 })] }), `${a3}${c3}`);
  }) }), c3.toString())) }));
}
var lr = () => {
  const { arrows: r2, newArrow: n2, boardOrientation: o2, boardWidth: i2, customArrowColor: s2 } = Jt(), a2 = [...r2, n2].filter(Boolean);
  return (0, import_jsx_runtime.jsx)("svg", Object.assign({ width: i2, height: i2, style: { position: "absolute", top: "0", left: "0", pointerEvents: "none", zIndex: "10" } }, { children: a2.map((n3, a3) => {
    const [c2, l2, u2] = n3;
    if (c2 === l2) return null;
    const d2 = Yt(o2, i2, c2), h2 = Yt(o2, i2, l2);
    let g2 = i2 / 32;
    const f2 = a3 === r2.length;
    r2.some((e3) => e3[0] !== c2 && e3[1] === l2) && !f2 && (g2 = i2 / 16);
    const p2 = h2.x - d2.x, m2 = h2.y - d2.y, y = Math.hypot(m2, p2), b2 = { x: d2.x + p2 * (y - g2) / y, y: d2.y + m2 * (y - g2) / y };
    return (0, import_jsx_runtime.jsxs)(import_react.Fragment, { children: [(0, import_jsx_runtime.jsx)("marker", Object.assign({ id: `arrowhead-${a3}`, markerWidth: "2", markerHeight: "2.5", refX: "1.25", refY: "1.25", orient: "auto" }, { children: (0, import_jsx_runtime.jsx)("polygon", { points: "0.3 0, 2 1.25, 0.3 2.5", fill: null != u2 ? u2 : s2 }) })), (0, import_jsx_runtime.jsx)("line", { x1: d2.x, y1: d2.y, x2: b2.x, y2: b2.y, opacity: f2 ? "0.5" : "0.65", stroke: null != u2 ? u2 : s2, strokeWidth: f2 ? 0.9 * i2 / 40 : i2 / 40, markerEnd: `url(#arrowhead-${a3})` })] }, `${c2}-${l2}${f2 ? "-active" : ""}`);
  }) }));
};
function ur({ option: t2 }) {
  const [r2, n2] = (0, import_react.useState)(false), { boardWidth: o2, chessPieces: i2, customDarkSquareStyle: s2, customLightSquareStyle: c2, handleSetPosition: l2, onPromotionPieceSelect: u2, promoteFromSquare: d2, promoteToSquare: h2, promotionDialogVariant: g2 } = Jt(), f2 = () => {
    switch (t2[1]) {
      case "Q":
        return s2.backgroundColor;
      case "R":
        return c2.backgroundColor;
      case "N":
        return "default" === g2 ? c2.backgroundColor : s2.backgroundColor;
      case "B":
        return "default" === g2 ? s2.backgroundColor : c2.backgroundColor;
    }
  };
  return (0, import_jsx_runtime.jsx)("div", Object.assign({ onClick: () => {
    (null == u2 ? void 0 : u2.length) ? u2(t2) : l2(d2, h2, t2, true);
  }, onMouseOver: () => n2(true), onMouseOut: () => n2(false), "data-piece": t2, style: { cursor: "pointer", backgroundColor: r2 ? f2() : `${f2()}aa`, borderRadius: "4px", transition: "all 0.1s ease-out" } }, { children: "function" == typeof i2[t2] ? (0, import_jsx_runtime.jsx)("div", Object.assign({ style: { transition: "all 0.1s ease-out", transform: r2 ? "scale(1)" : "scale(0.85)" } }, { children: i2[t2]({ squareWidth: o2 / 8, isDragging: false }) })) : (0, import_jsx_runtime.jsx)("svg", Object.assign({ viewBox: "1 1 43 43", width: o2 / 8, height: o2 / 8, style: { transition: "all 0.1s ease-out", transform: r2 ? "scale(1)" : "scale(0.85)" } }, { children: (0, import_jsx_runtime.jsx)("g", { children: i2[t2] }) })) }));
}
function dr() {
  const { boardOrientation: t2, boardWidth: r2, promotionDialogVariant: n2, promoteToSquare: o2 } = Jt(), i2 = "1" === (null == o2 ? void 0 : o2[1]) ? "b" : "w", s2 = [`${null != i2 ? i2 : "w"}Q`, `${null != i2 ? i2 : "w"}R`, `${null != i2 ? i2 : "w"}N`, `${null != i2 ? i2 : "w"}B`], a2 = { default: { display: "grid", gridTemplateColumns: "1fr 1fr", transform: `translate(${-r2 / 8}px, ${-r2 / 8}px)` }, vertical: { transform: `translate(${-r2 / 16}px, ${-r2 / 16}px)` }, modal: { display: "flex", justifyContent: "center", alignItems: "center", transform: `translate(0px, ${3 * r2 / 8}px)`, width: "100%", height: r2 / 4 + "px", top: 0, backgroundColor: "white", left: 0 } }, c2 = Yt(t2, r2, o2 || "a8");
  return (0, import_jsx_runtime.jsx)("div", Object.assign({ style: Object.assign({ position: "absolute", top: `${null == c2 ? void 0 : c2.y}px`, left: `${null == c2 ? void 0 : c2.x}px`, zIndex: 1e3 }, a2[n2]), title: "Choose promotion piece" }, { children: s2.map((t3) => (0, import_jsx_runtime.jsx)(ur, { option: t3 }, t3)) }));
}
var hr = { whiteKing: (0, import_jsx_runtime.jsx)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", style: { shapeRendering: "geometricPrecision", textRendering: "geometricPrecision", imageRendering: "crisp-edges" }, viewBox: "0 0 4210 12970", x: "0px", y: "0px", fillRule: "evenodd", clipRule: "evenodd", width: "250", height: "250" }, { children: (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)("path", { style: { fill: "black", fillRule: "nonzero" }, d: "M2105 0c169,0 286,160 249,315l200 0c-172,266 -231,479 -256,792 315,-24 530,-86 792,-255l0 897c-265,-171 -479,-231 -792,-256 18,234 75,495 185,682l339 0c233,0 369,269 225,456l545 0 -595 1916c130,94 158,275 59,402 465,0 416,568 51,568l-334 0 465 2867 332 0c250,0 381,306 199,485 162,63 273,220 273,399l0 633 168 0 0 475c-1403,0 -2807,0 -4210,0l0 -475 167 0 0 -633c0,-179 112,-336 274,-399 -181,-178 -52,-485 199,-485l332 0 465 -2867 -335 0c-353,0 -418,-568 51,-568 -98,-127 -70,-308 59,-402l-594 -1916c181,0 363,0 545,0 -144,-187 -9,-456 225,-456l339 0c110,-187 167,-448 185,-682 -315,25 -530,87 -793,256l0 -897c266,171 480,231 793,255 -25,-315 -87,-529 -256,-792l199 0c-36,-155 81,-315 250,-315zm-1994 10012l0 253 3988 0 0 -253c-1330,0 -2659,0 -3988,0zm484 -1060c-174,0 -316,142 -316,316l0 633 3652 0 0 -633c0,-174 -142,-316 -316,-316 -1007,0 -2013,0 -3020,0zm45 -457c-230,0 -225,345 0,345l2930 0c230,0 225,-345 0,-345 -977,0 -1953,0 -2930,0zm2020 -2978l-1111 0 -465 2867 2041 0 -465 -2867zm-1558 -456c-229,0 -224,345 0,345 669,0 1337,0 2005,0 230,0 225,-345 0,-345 -668,0 -1336,0 -2005,0zm1730 -457l-1454 0c-229,0 -224,345 0,345l1454 0c229,0 224,-345 0,-345zm-2064 -1862l544 1751c529,0 1057,0 1586,0l544 -1751c-892,0 -1783,0 -2674,0zm1085 -567l504 0c-126,-247 -163,-526 -177,-800 273,15 553,52 800,177l0 -504c-247,126 -527,163 -800,177 14,-273 51,-552 177,-799 -168,0 -336,0 -504,0 125,247 162,526 177,799 -274,-14 -553,-51 -800,-177l0 504c247,-125 527,-162 800,-177 -15,274 -52,553 -177,800zm969 111l-1434 0c-230,0 -225,345 0,345l1434 0c230,0 225,-345 0,-345zm-717 -2175c-105,0 -175,109 -133,204l266 0c42,-96 -30,-205 -133,-204z" }) }) })) };
function gr({ children: t2 }) {
  try {
    return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: t2 });
  } catch (t3) {
    return console.log(t3), (0, import_jsx_runtime.jsx)(fr, { showError: true });
  }
}
function fr({ showError: r2 = false }) {
  return (0, import_jsx_runtime.jsxs)("div", Object.assign({ style: { display: "flex", justifyContent: "center", alignItems: "center", flexDirection: "column" } }, { children: [(0, import_jsx_runtime.jsx)("div", Object.assign({ style: { width: 250, height: 250, transform: "rotate(90deg)" } }, { children: hr.whiteKing })), r2 && (0, import_jsx_runtime.jsx)("h1", { children: "Something went wrong" })] }));
}
function pr() {
  const n2 = (0, import_react.useRef)(null), { boardWidth: o2, clearCurrentRightClickDown: s2, onPromotionPieceSelect: a2, setShowPromoteDialog: c2, showPromoteDialog: l2, customBoardStyle: u2 } = Jt();
  return (0, import_react.useEffect)(() => {
    function e3(e4) {
      n2.current && !n2.current.contains(e4.target) && s2();
    }
    return document.addEventListener("mouseup", e3), () => {
      document.removeEventListener("mouseup", e3);
    };
  }, []), o2 ? (0, import_jsx_runtime.jsx)("div", Object.assign({ style: { perspective: "1000px" } }, { children: (0, import_jsx_runtime.jsxs)("div", Object.assign({ ref: n2, style: Object.assign(Object.assign({ position: "relative" }, vr(o2)), u2) }, { children: [(0, import_jsx_runtime.jsx)(cr, {}), (0, import_jsx_runtime.jsx)(lr, {}), l2 && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("div", { onClick: () => {
    c2(false), null == a2 || a2();
  }, style: { position: "absolute", top: "0", left: "0", zIndex: "100", backgroundColor: "rgba(22,21,18,.7)", width: o2, height: o2 } }), (0, import_jsx_runtime.jsx)(dr, {})] })] })) })) : (0, import_jsx_runtime.jsx)(fr, {});
}
var vr = (e3) => ({ cursor: "default", height: e3, width: e3 });
function mr({ boardContainer: t2 }) {
  const { boardWidth: r2, chessPieces: n2, id: o2, snapToCursor: s2, allowDragOutsideBoard: a2 } = Jt(), l2 = function(e3) {
    const t3 = Je().getMonitor(), [r3, n3] = Re(t3, e3);
    return (0, import_react.useEffect)(() => t3.subscribeToOffsetChange(n3)), (0, import_react.useEffect)(() => t3.subscribeToStateChange(n3)), r3;
  }((e3) => ({ item: e3.getItem(), clientOffset: e3.getClientOffset(), sourceClientOffset: e3.getSourceClientOffset(), isDragging: e3.isDragging() })), { isDragging: u2, item: d2, clientOffset: h2, sourceClientOffset: g2 } = l2, f2 = (0, import_react.useCallback)((e3, n3) => {
    if (!e3 || !n3) return { display: "none" };
    let { x: o3, y: i2 } = s2 ? e3 : n3;
    const c2 = r2 / 8 / 2;
    if (s2 && (o3 -= c2, i2 -= c2), !a2) {
      const { left: e4, top: n4 } = t2, s3 = e4 - c2, a3 = n4 - c2, l4 = e4 + r2 - c2, u3 = n4 + r2 - c2;
      o3 = Math.max(s3, Math.min(o3, l4)), i2 = Math.max(a3, Math.min(i2, u3));
    }
    const l3 = `translate(${o3}px, ${i2}px)`;
    return { transform: l3, WebkitTransform: l3, touchAction: "none" };
  }, [r2, a2, s2, t2]);
  return u2 && d2.id === o2 ? (0, import_jsx_runtime.jsx)("div", Object.assign({ style: { position: "fixed", pointerEvents: "none", zIndex: 10, left: 0, top: 0 } }, { children: (0, import_jsx_runtime.jsx)("div", Object.assign({ style: f2(h2, g2) }, { children: "function" == typeof n2[d2.piece] ? n2[d2.piece]({ squareWidth: r2 / 8, isDragging: true }) : (0, import_jsx_runtime.jsx)("svg", Object.assign({ viewBox: "1 1 43 43", width: r2 / 8, height: r2 / 8 }, { children: (0, import_jsx_runtime.jsx)("g", { children: n2[d2.piece] }) })) })) })) : null;
}
var yr = (0, import_react.forwardRef)((r2, n2) => {
  var o2;
  const { customDndBackend: s2, customDndBackendOptions: c2 } = r2, l2 = function(e3, t2) {
    var r3 = {};
    for (var n3 in e3) Object.prototype.hasOwnProperty.call(e3, n3) && t2.indexOf(n3) < 0 && (r3[n3] = e3[n3]);
    if (null != e3 && "function" == typeof Object.getOwnPropertySymbols) {
      var o3 = 0;
      for (n3 = Object.getOwnPropertySymbols(e3); o3 < n3.length; o3++) t2.indexOf(n3[o3]) < 0 && Object.prototype.propertyIsEnumerable.call(e3, n3[o3]) && (r3[n3[o3]] = e3[n3[o3]]);
    }
    return r3;
  }(r2, ["customDndBackend", "customDndBackendOptions"]), [u2, d2] = (0, import_react.useState)(), [h2, g2] = (0, import_react.useState)(false), [p2, v2] = (0, import_react.useState)(false), [m2, y] = (0, import_react.useState)(r2.boardWidth), b2 = (0, import_react.useRef)(null), O2 = (0, import_react.useRef)(null), [w2, S2] = (0, import_react.useState)({ left: 0, top: 0 }), D2 = null === (o2 = b2.current) || void 0 === o2 ? void 0 : o2.getBoundingClientRect();
  (0, import_react.useEffect)(() => {
    S2({ left: (null == D2 ? void 0 : D2.left) ? null == D2 ? void 0 : D2.left : 0, top: (null == D2 ? void 0 : D2.top) ? null == D2 ? void 0 : D2.top : 0 });
  }, [D2]), (0, import_react.useEffect)(() => {
    v2("ontouchstart" in window), g2(true), d2(window);
  }, []), (0, import_react.useEffect)(() => {
    var e3;
    if (void 0 === r2.boardWidth && (null === (e3 = b2.current) || void 0 === e3 ? void 0 : e3.offsetWidth)) {
      const e4 = new ResizeObserver(() => {
        var e5;
        y(null === (e5 = b2.current) || void 0 === e5 ? void 0 : e5.offsetWidth);
      });
      return e4.observe(b2.current), () => {
        e4.disconnect();
      };
    }
  }, [b2.current, u2]);
  const C2 = s2 || (p2 ? Ht : kt);
  return h2 && u2 ? (0, import_jsx_runtime.jsx)(gr, { children: (0, import_jsx_runtime.jsxs)("div", Object.assign({ ref: O2, style: { display: "flex", flexDirection: "column", width: "100%" } }, { children: [(0, import_jsx_runtime.jsx)("div", { ref: b2, style: { width: "100%" } }), (0, import_jsx_runtime.jsx)(xe, Object.assign({ backend: C2, context: u2, options: s2 ? c2 : void 0 }, { children: m2 && (0, import_jsx_runtime.jsxs)(Zt, Object.assign({ boardWidth: m2 }, l2, { ref: n2 }, { children: [(0, import_jsx_runtime.jsx)(mr, { boardContainer: w2 }), (0, import_jsx_runtime.jsx)(pr, {})] })) }))] })) }) : null;
});
export {
  yr as Chessboard
};
//# sourceMappingURL=react-chessboard.js.map
